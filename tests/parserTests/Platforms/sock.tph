'**************************************************************************************************
'       SOCK (Socket) object
'**************************************************************************************************

object sock
'This is the sockets object that encompasses ALL available sockets. Total number of sockets is typically 16 but can be
'less due to memory limitations of a particular platform. The number of available sockets can be obtained through
'the <font color="maroon"><b>sock.numofsock </b></font> read-only property. <br><br>
'Selection of a particular socket to work with is done through the <font color="maroon"><b>sock.num </b></font>property. Most other 
'properties and methods refer to the currently selected socket. <br><br>
'When the handler for one of the socket events is entered the <font color="maroon"><b>sock.num  </b></font>is automatically switched 
'to the socket for which this event was generated.   

'--------------------------------------------------------------------
enum pl_sock_state
'<b>ENUM. </b><br><br> Contains the list of constants related to possible socket states. See also enum <font color="olive"><b>pl_sock_state_simple</b></font>.
    PL_SST_CLOSED=0,            '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (and haven't been opened yet, it is a
                                'post-powerup state). <br><br>Applies both to UDP and TCP.
    PL_SST_CL_PCLOSED,          '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive close). <br><br>Applies only to TCP.
    PL_SST_CL_ACLOSED,          '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active close by the
                                'application). <br><br>Applies only to TCP.
    PL_SST_CL_PRESET_POPENING,  '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset during a
                                'passive open).<br><br> Applies only to TCP.
    PL_SST_CL_PRESET_AOPENING,  '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset during an
                                'active open). <br><br>Applies only to TCP.
    PL_SST_CL_PRESET_EST,       '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset while in
                                '"connection established" state). <br><br>Applies only to TCP.
    PL_SST_CL_PRESET_PCLOSING,  '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset while performing
                                'a passive close). Applies only to TCP.
    PL_SST_CL_PRESET_ACLOSING,  '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset while performing
                                'an active close). <br><br>Applies only to TCP.
    PL_SST_CL_PRESET_STRANGE,   '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was a passive reset, no further
                                'details available). <br><br>Applies only to TCP.
    PL_SST_CL_ARESET_CMD,       '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued by the
                                'application). <br><br>Applies only to TCP.
    PL_SST_CL_ARESET_RE_PO,     '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
                                'of excessive retransmission attempts during a passive open). <br><br>Applies only to TCP.
    PL_SST_CL_ARESET_RE_AO,     '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
                                'of excessive retransmission attempts during an active open). <br><br>Applies only to TCP.
    PL_SST_CL_ARESET_RE_EST,    '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
                                'of excessive retransmission attempts while in "connection established" state).
                                '<br><br>Applies only to TCP.
    PL_SST_CL_ARESET_RE_PC,     '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
                                'of excessive retransmission attempts during a passive close). <br><br>Applies only to TCP.
    PL_SST_CL_ARESET_RE_AC,     '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset issued because
                                'of excessive retransmission attempts during a passive open). <br><br>Applies only to TCP.
    PL_SST_CL_ARESET_TOUT,      '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset caused by
                                'connection timeout, i.e. no data was exchanged for sock.connectiontout number of
                                'seconds). <br><br>Applies only to TCP.
    PL_SST_CL_ARESET_DERR,      '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was an active reset caused by
                                'a data exchange error). <br><br>Applies only to TCP.
    PL_SST_CL_DISCARDED_CMD,    '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded by the application).
                                '<br><br>Applies both to UDP and TCP.
    PL_SST_CL_DISCARDED_PO_WCS, '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because an error
                                'in connection sequence was detected during a passive open). <br><br>Applies only to TCP.
    PL_SST_CL_DISCARDED_AO_WCS, '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because an error
                                'in connection sequence was detected during an active open). <br><br>Applies only to TCP.
    PL_SST_CL_DISCARDED_ARPFL,  '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because the device has
                                'failed to resolve the IP address of the destination during an active open, i.e.
                                'there was no reply to ARP requests). <br><br>Applies both to UDP and TCP.
    PL_SST_CL_DISCARDED_TOUT,   '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed (it was discarded because connection has 
                                'timed out, i.e. no data was exchanged for sock.connectiontout number of seconds). <br><br>
                                'Applies only to UDP.
    PL_SST_ARP=&h20,            '<b>PLATFORM CONSTANT. </b><br><br> ARP resolution is an progress (it is an active open).
                                '<br><br>Applies both to UDP and TCP.
    PL_SST_PO=&h40,             '<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is a passive open).
                                '<br><br>Applies only to TCP.
    PL_SST_AO=&h60,             '<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is an active open).
                                '<br><br>Applies only to TCP.
    PL_SST_EST=&h80,            '<b>PLATFORM CONSTANT. </b><br><br> Connection is established (generic, includes both passive
                                'and active open). <br><br>Applies both to UDP and TCP.  
    PL_SST_EST_POPENED=&h80,    '<b>PLATFORM CONSTANT. </b><br><br> Connection is established (it was a passive open).
                                '<br><br>Applies both to UDP and TCP. 
    PL_SST_EST_AOPENED,         '<b>PLATFORM CONSTANT. </b><br><br> Connection is established (it was an active open).
                                '<br><br>Applies both to UDP and TCP.
    PL_SST_PC=&hA0,             '<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is a passive close).
                                '<br><br>Applies only to TCP. 
    PL_SST_AC=&hC0              '<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is an active close).
                                '<br><br>Applies only to TCP.
end enum

'--------------------------------------------------------------------
enum pl_sock_state_simple
'<b>ENUM. </b><br><br> Contains a simplified list of constants related to possible socket states. See also enum <font color="olive"><b>pl_sock_state</b></font>.
    PL_SSTS_CLOSED,     '<b>PLATFORM CONSTANT. </b><br><br> Connection is closed. <br><br>Applies both to UDP and TCP.
    PL_SSTS_ARP,        '<b>PLATFORM CONSTANT. </b><br><br> ARP resolution is an progress (it is an active open).
                        '<br><br>Applies both to UDP and TCP.
    PL_SSTS_PO,         '<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is a passive open).
                        '<br><br>Applies only to TCP.
    PL_SSTS_AO,         '<b>PLATFORM CONSTANT. </b><br><br> Connection is being established (it is an active open).
                        '<br><br>Applies only to TCP.
    PL_SSTS_EST,        '<b>PLATFORM CONSTANT. </b><br><br> Connection is established. <br><br>Applies both to UDP and TCP.  
    PL_SSTS_PC,         '<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is a passive close).
                        '<br><br>Applies only to TCP. 
    PL_SSTS_AC          '<b>PLATFORM CONSTANT. </b><br><br> Connection is being closed (it is an active close).
                        '<br><br>Applies only to TCP.
end enum

'--------------------------------------------------------------------
enum pl_sock_inconmode
'<b>ENUM. </b><br><br> 
'Contains the list of constants related to whether the socket accepts any incoming connections and, if yes, from which sources.
    PL_SOCK_INCONMODE_NONE,         '<b>PLATFORM CONSTANT. </b><br><br> The socket does not accept any incoming connections.
    PL_SOCK_INCONMODE_SPECIFIC_IPPORT,  '<b>PLATFORM CONSTANT. </b><br><br> 
                                        'The socket will only accept an incoming connection from specific IP (matching <font color="maroon">
                                        '<b>sock.targetip</b></font>) and specific port (matching <font color="maroon"><b>
                                        'sock.targetport</b></font>)
    PL_SOCK_INCONMODE_SPECIFIC_IP_ANY_PORT, '<b>PLATFORM CONSTANT. </b><br><br> 
                                            'The socket will only accept an incoming connection from specific IP (matching <font color="maroon">
                                            '<b>sock.targetip</b></font>), but any port.
    PL_SOCK_INCONMODE_ANY_IP_ANY_PORT   '<b>PLATFORM CONSTANT. </b><br><br> 
                                        'The socket will accept an incoming connection from any IP and any port.
end enum

'--------------------------------------------------------------------
enum pl_sock_reconmode
'<b>ENUM. </b><br><br> 
'Contains the list of constants that specify whether the socket accepts reconnects, and, if yes, from which sources. Reconnect situation is 
'when a passive open and resulting connection replace, for the same socket, the connection that was already in progress. <br><br>
'For UDP, these constants additionally define whether a "port switchover" will occur as a result of an incoming connection (passive open)
'or a reconnect.<br><br>
'Port switchover is when the socket starts sending its outgoing UDP datagrams to the port from which the most recent UDP datagram was received,
'rather than the port specified by the <font color="maroon"><b>sock.targetport </b></font> property.
    PL_SOCK_RECONMODE_0,        '<b>PLATFORM CONSTANT. </b><br><br> 
                                'For UDP: Reconnects accepted only from the same IP as the one already engaged in the current connection 
                                'with this socket, but any port; port switchover will not happen. <br><br>
                                'TCP: reconnects are not accepted at all.
    PL_SOCK_RECONMODE_1,        '<b>PLATFORM CONSTANT. </b><br><br> 
                                'For UDP: Reconnects accepted from any IP, any port; port switchover will not happen. <br><br>
                                'TCP: reconnects accepted only from the same IP and port as the ones already engaged in the current connection 
                                'with this socket.
    PL_SOCK_RECONMODE_2,        '<b>PLATFORM CONSTANT. </b><br><br> 
                                'For UDP: Reconnects accepted only from the same IP as the one already engaged in the current connection with 
                                'this socket, but any port; port switchover will happen. <br><br>
                                'TCP: reconnects accepted only from the same IP as the one already engaged in the current connection with this
                                'socket, but any port.
    PL_SOCK_RECONMODE_3         '<b>PLATFORM CONSTANT. </b><br><br> 
                                'For UDP: Reconnects accepted from any IP, any port; port switchover will happen. ,<br><br>
                                'TCP: reconnects accepted from any IP, any port.
end enum

'--------------------------------------------------------------------
enum pl_sock_protocol
'<b>ENUM. </b><br><br> 
'Contains the list of constants that specify the transport protocol for the socket. HTTP is not listed here because it is not a transport
'protocol (transport protocol used for HTTP is TCP).
    PL_SOCK_PROTOCOL_UDP,       '<b>PLATFORM CONSTANT. </b><br><br> Specifies UDP transport protocol for the socket.
    PL_SOCK_PROTOCOL_TCP,       '<b>PLATFORM CONSTANT. </b><br><br> Specifies TCP transport protocol for the socket.
    PL_SOCK_PROTOCOL_RAW        '<b>PLATFORM CONSTANT. </b><br><br> Specifies RAW packet mode for the socket.
end enum

'--------------------------------------------------------------------
enum pl_http_rq_type
'<b>ENUM. </b><br><br> 
'Contains the list of HTTP request types supported by the internal web server.
    PL_SOCK_HTTP_RQ_GET,        '<b>PLATFORM CONSTANT. </b><br><br> HTTP GET request.
    PL_SOCK_HTTP_RQ_POST        '<b>PLATFORM CONSTANT. </b><br><br> HTTP POST request.
end enum

'--------------------------------------------------------------------
property sock.numofsock
'<b>R/O PROPERTY (BYTE). </b><br><br> Returns total number of sockets available on the current platform. See also <font color="maroon"><b>
'sock.num </b></font>property.
    get = syscall(248) as byte
end property

'--------------------------------------------------------------------
property sock.num
'<b>PROPERTY (BYTE), DEFAULT VALUE= 0 (socket #0 selected). </b><br><br>
'Sets/returns the number of the currently selected socket (sockets are enumerated from 0).<br><br>
'Most other properties and methods of this object relate to the socket selected through this property. Note that socket-related events such 
'as <font color="teal"><b>on_sock_data_arrival </b></font> change currently selected socket!<br><br>
'The value of this property won't exceed <font color="maroon"><b>sock.numofsock</b></font>-1 (even if you attempt to set higher value).
    get = syscall(203) as byte
    set = syscall(204) (sock as byte)
end property

'--------------------------------------------------------------------
property sock.state
'<b>R/O PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0-PL_SST_CLOSED (connection is closed). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns "detailed" current socket state
'(as opposed to <font color="teal"><b>on_sock_event </b></font>that retuns detailed state at the moment of a particular <font color="teal">
'<b>on_sock_event </b></font>event generation).See <font color="olive"><b>pl_sock_state </b></font>constants for state descriptions.<br><br>
'Another read-only property- <font color="maroon"><b>sock.statesimple</b></font>- returns "simplified" socket state.
  
    get = syscall(224) as pl_sock_state
end property

'--------------------------------------------------------------------
property sock.statesimple
'<b>R/O PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0-PL_SST_SIMPLE_CLOSED (connection is closed). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns "simplified" current socket state
'(as opposed to <font color="teal"><b>on_sock_event </b></font> that retuns simplified state at the moment of a particular <font color="teal">
'<b>on_sock_event </b></font> event generation). See <font color="olive"><b>pl_sock_state_simple </b></font>constants for state
'descriptions.<br><br>
'Another read-only property- <font color="maroon"><b>sock.state</b></font>- returns "detailed" socket state.
    get = syscall(185) as pl_sock_state_simple
end property

'--------------------------------------------------------------------
property sock.inconmode
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_INCONMODE_NONE (does not accept any incoming connections). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether incoming connections
'(passive opens) will be accepted and, if yes, from which sources: <br><br>
'<font color="olive"><b>0- PL_SOCK_INCONMODE_NONE </b></font>(incoming connections are not accepted at all),<br><br>
'<font color="olive"><b>1- PL_SOCK_INCONMODE_SPECIFIC_IPPORT </b></font>(incoming connections accepted only from specific IP (matching 
'<font color="maroon"><b>sock.targetip</b></font>) and specific port (matching <font color="maroon"><b>sock.targetport</b></font>)), <br><br>
'<font color="olive"><b>2- PL_SOCK_INCONMODE_SPECIFIC_IP_ANY_PORT </b></font>(incoming connections accepted only from specific IP (matching 
'<font color="maroon"><b>sock.targetip</b></font>), but any port),<br><br>
'<font color="olive"><b>3- PL_SOCK_INCONMODE_ANY_IP_ANY_PORT </b></font>(incoming connections accepted from any IP and any port). 
    get = syscall(192,"36.TDL"+) as pl_sock_inconmode
    set = syscall(193,"36.TDL"+) (inconmode as pl_sock_inconmode)
end property

'--------------------------------------------------------------------
property sock.reconmode
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_RECONMODE_0. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) whether the socket accepts reconnects, 
'and, if yes, from which sources. Reconnect situation is when a passive open and resulting connection replace, for the same socket, the 
'connection that was already in progress. <br><br>
'For UDP, this property additionally defines whether a "port switchover" will occur as a result of an incoming connection (passive open) or a
'reconnect. Port switchover is when the socket starts sending its outgoing UDP datagrams to the port from which the most recent UDP datagram
'was received, rather than the port specified by the <font color="maroon"><b>sock.targetport</b></font> property. <br><br>
'See <font color="olive"><b>PL_SOCK_RECONMODE_ </b></font>constants for available choices.
    get = syscall(246,"36.TDL"+) as pl_sock_reconmode
    set = syscall(247,"36.TDL"+) (reconmode as pl_sock_reconmode)
end property

'--------------------------------------------------------------------
property sock.localportlist
'<b>PROPERTY (STRING), DEFAULT VALUE= "" (empty string). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns the list of listening ports
'on any of which this socket will accept an incoming UDP or TCP connection (as defined by the <font color="maroon"><b>sock.protocol </b></font>
'property and provided that incoming connections are allowed by the <font color="maroon"><b>sock.inconmode </b></font> property).
'Additionally, the
'<font color="maroon"><b>sock.allowedinterfaces </b></font>
'property defines network interfaces on which the socket will accept an incoming connection.
'<br><br>
'This property is of string type and the list of ports is a comma-separated string, i.e. "1001,3000". Max string length for this property is 
'32 bytes. <br><br>
'Notice, that there is also a <font color="maroon"><b>sock.httpportlist </b></font> property that defines a list of listening ports for HTTP 
'TCP connections.
    get = syscall(210,"36.TDL"+) as string
    set = syscall(211,"36.TDL"+) (byref lplist as string)
end property

'--------------------------------------------------------------------
property sock.httpportlist
'<b>PROPERTY (STRING), DEFAULT VALUE= "" (empty string). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns the list of listening ports
'on any of which this socket will accept an incoming HTTP connection. (provided that the <font color="maroon"><b>sock.protocol</b></font>= 
'<font color="olive"><b>1- PL_SOCK_PROTOCOL_TCP</b></font> and that incoming connections are allowed by <font color="maroon"><b>
'sock.inconmode</b></font> property). <br><br>
'This property is of string type and the list of ports is a comma-separated string, i.e. "80, 81". Max string length for this property is 32 
'bytes. Notice, that there is also a <font color="maroon"><b>sock.localportlist</b></font> property that defines a list of listening ports for
'UDP and non-HTTP TCP connections. <br><br>
'When a particular port is listed both under the <font color="maroon"><b>sock.localportlist</b></font> and the <font color="maroon"><b>
'sock.httpportlist</b></font>, the protocol for this socket is TCP then <font color="maroon"><b>sock.httpportlist</b></font> has precedence
'(incoming TCP connection on the port in question will be interpreted as HTTP). <br><br>
'See also <font color="maroon"><b>sock.localport </b></font> and <font color="maroon"><b>sock.httpmode </b></font> properties. 
    get = syscall(48,"36.TDL"+) as string
    set = syscall(49,"36.TDL"+) (byref hplist as string)
end property

'--------------------------------------------------------------------
property sock.localport
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current local port of the socket.
'<br><br>Your application cannot set the local port directly. Instead, a list of ports on which the socket is allowed to accept an incoming 
'connection (passive open) is supplied via the <font color="maroon"><b>sock.localportlist </b></font> and <font color="maroon"><b>
'sock.httpportlist </b></font> properties.<br><br>
'An incoming connection is accepted on any port from those two lists. The <font color="maroon"><b>sock.localport </b></font> property reflects 
'current or the most recent local port on which connection was accepted.
    get = syscall(209) as word
end property

'--------------------------------------------------------------------
property sock.outport
'<b>PROPERTY (WORD), DEFAULT VALUE= 0 (automatic). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns the number of the port that
'will be used by the socket to establish outgoing connections. <br><br>
'If this property is set to 0 then the socket will use "automatic" port numbers: for the first connection since the powerup the port number will
'be selected randomly, for all subsequent outgoing connections the port number will increase by one. <br><br>
'Actual local port of a connection can be queried through the <font color="maroon"><b>sock.localport </b></font> read-only property. If this 
'property is not at zero then the port it specifies will be used for all outgoing connections from this socket.
    get = syscall(190,"81.TDL"+) as word
    set = syscall(191,"81.TDL"+) (outport as word)
end property

'--------------------------------------------------------------------
property sock.acceptbcast
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0-NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether the socket will accept
'incoming broadcast UDP datagrams: <br><br>
'<font color="olive"><b>0- NO </b></font>(won't accept broadcast UDP datagrams),<br><br> <font color="olive"><b>1- YES </b></font> (will accept
'broadcast UDP datagrams).<br><br>
'This property is irrelevant for TCP communications (<font color="maroon"><b>sock.protocol</b></font>=<font color="olive"><b>
'PL_SOCK_PROTOCOL_TCP</b></font>).
    get = syscall(205,"81.TDL"+) as no_yes
    set = syscall(206,"81.TDL"+) (acceptbcast as no_yes)
end property

'--------------------------------------------------------------------
property sock.targetip
'<b>PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0". </b><br><br>
'For active opens on the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the target IP
'to which the socket will attempt to connect to. <br><br>
'For passive opens, whether this property will matter or not is defined by the <font color="maroon"><b>sock.inconmode</b></font> property. 
'When the <font color="maroon"><b>sock.inconmode</b></font>= <font color="olive"><b>1- PL_SOCK_INCONMODE_SPECIFIC_IPPORT </b></font> or
'<font color="olive"><b>2- PL_SOCK_INCONMODE_SPECIFIC_IP_ANY_PORT </b></font> only the host with IP matching the one set in the 
'<font color="maroon"><b>sock.targetip</b></font> property will be able to connect to the socket.<br><br>
'current IP on the "other side" of the connection can always be checked through the <font color="maroon"><b>sock.remoteip </b></font> read-only
'property.<br><br> 
'See also <font color="maroon"><b>sock.targetport</b></font> and <font color="maroon"><b>sock.remoteport</b></font>.
    get = syscall(212,"39.TDL"+) as string
    set = syscall(213,"40.TDL"+) (byref targetip as string)
end property

'--------------------------------------------------------------------
property sock.targetmac
'<b>PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0.0.0". </b><br><br>
    get = syscall(482,"39.TDL"+) as string
    set = syscall(483,"40.TDL"+) (byref targetip as string)
end property

'--------------------------------------------------------------------
property sock.targetport
'<b>PROPERTY (WORD), DEFAULT VALUE= 0. </b><br><br>
'For active opens on the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the target port
'to which the socket will attempt to connect to. <br><br>
'For passive opens, whether this property will matter or not is defined by the <font color="maroon"><b>sock.inconmode</b></font> property. 
'When the <font color="maroon"><b>sock.inconmode</b></font>= <font color="olive"><b>1- PL_SOCK_INCONMODE_SPECIFIC_IPPORT </b></font> an incoming
'connection will only be accepted from the port matching the one set in the <font color="maroon"><b>sock.targetport</b></font> property.<br><br>
'Current port on the "other side" of the connection can always be checked through the <font color="maroon"><b>sock.remoteport</b></font>
'read-only property.<br><br>
'See also <font color="maroon"><b>sock.targetip</b></font> and <font color="maroon"><b>sock.remoteip</b></font>.
    get = syscall(214,"81.TDL"+) as word
    set = syscall(215,"81.TDL"+) (targetport as word)
end property

'--------------------------------------------------------------------
property sock.targetbcast
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether this port will be
'sending its outgoing UDP datagrams as link-level broadcasts: <br><br>
'<font color="olive"><b>0- NO </b></font> (will send as "normal" packets),<br><br> <font color="olive"><b>1- YES </b></font>(will send as 
'broadcast packets).<br><br>
'This property is only relevant for UDP communications (<font color="maroon"><b>sock.protocol</b></font>=<font color="olive"><b>
'PL_SOCK_PROTOCOL_UDP</b></font>). When this property is set to <font color="olive"><b>1- YES </b></font>the socket will be sending out all UDP 
'datagrams as broadcasts and incoming datagrams won't cause port switchover, even if the latter is enabled through the 
'<font color="maroon"><b>sock.reconmode </b></font> property.
    get = syscall(216,"81.TDL"+) as no_yes
    set = syscall(217,"81.TDL"+) (targetbcast as no_yes)
end property

'--------------------------------------------------------------------
property sock.remotemac
'<b>R/O PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0.0.0". </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the MAC address of the host with
'which this socket had the most recent or currently has a connection. <br><br>
'For UDP connections, when the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>
'sock.remotemac </b></font>will contain the MAC address of the sender of the current UDP datagram being processed.<br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the source MAC address of the most
'recent datagram received by the socket. <br><br>
'Also see <font color="maroon"><b>sock.remoteip</b></font>, <font color="maroon"><b>sock.remoteport</b></font>, and <font color="maroon"><b>
'sock.bcast </b></font> properties.
    get = syscall(220,"39.TDL"+) as string
end property

'--------------------------------------------------------------------
property sock.remoteip
'<b>R/O PROPERTY (STRING), DEFAULT VALUE= "0.0.0.0". </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the IP address of the host with 
'which this socket had the most recent or currently has a connection. The application cannot directly change this property, it can only specify
'the target IP address for active opens through the <font color="maroon"><b>sock.targetip </b></font> property.<br><br>
'For UDP connections, when the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>
'sock.remoteip </b></font> will contain the IP address of the sender of the current datagram being processed. <br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the source IP address of the most
'recent datagram received by the socket.<br><br>
'Also see <font color="maroon"><b>sock.remotemac</b></font>, <font color="maroon"><b>sock.remoteport</b></font>, and <font color="maroon"><b>
'sock.bcast </b></font> properties. 
    get = syscall(221,"39.TDL"+) as string
end property

'--------------------------------------------------------------------
property sock.remoteport
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the port number of the host with
'which this socket had the most recent or currently has a connection. The application cannot directly change this property, it can only specify
'the target port for active opens through the <font color="maroon"><b>sock.targetport </b></font> property. <br><br>
'For UDP connections, when the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>
'sock.remoteport</b></font> will contain the port number of the sender of the current datagram being processed. <br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the source port of the most recent
'datagram received by the socket.<br><br>
'Also see <font color="maroon"><b>sock.remotemac</b></font>, <font color="maroon"><b>sock.remoteip</b></font>, and <font color="maroon"><b>
'sock.bcast </b></font> properties.
    get = syscall(222) as word
end property

'--------------------------------------------------------------------
property sock.bcast
'<b>R/O PROPERTY (ENUM BYTE), DEFAULT VALUE= 0- NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) reports whether the current or most
'recently received UDP datagram was a broadcast one. <br><br>
'When the <font color="teal"><b>on_sock_data_arrival </b></font>event handler is entered, the <font color="maroon"><b>sock.bcast </b></font> 
'will contain the broadcast status for the current datagram being processed.  <br><br>
'Outside of the <font color="teal"><b>on_sock_data_arrival </b></font>event handler, the property will return the broadcast status of the most
'recent datagram received by the socket.
    get = syscall(223) as no_yes
end property

'--------------------------------------------------------------------
property sock.protocol
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_PROTOCOL_UDP (UDP transport protocol for the socket). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num </b></font>) selects the transport protocol:<br><br>
'<font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP </b></font> (UDP transport protocol), <br><br>
'<font color="olive"><b>1- PL_SOCK_PROTOCOL_TCP</b></font> (TCP transport protocol).<br><br>
'Notice, that there is no "HTTP" selection, as HTTP is not a transport protocol (TCP is the transport protocol required by the HTTP). 
'You make the socket accept HTTP connections by specifying the list of HTTP listening ports using the <font color="maroon"><b>sock.httpportlist
'</b></font> property or using the <font color="maroon"><b>sock.httpmode </b></font> property. <br><br>
'The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>sock.statesimple
'</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).
    get = syscall(207,"36.TDL"+) as pl_sock_protocol
    set = syscall(208,"36.TDL"+) (proto as pl_sock_protocol)
end property

'--------------------------------------------------------------------
property sock.splittcppackets
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) selects how TCP data should be processed:
' <font color="olive"><b>0- NO </b></font>(normal processing), <font color="olive"><b>1- YES </b></font>(additional degree of control over
'individual TCP packets). When this property is set to <font color="olive"><b>1- YES </b></font>your program gets an additional degree of 
'control over TCP. <br><br>
'For incoming  TCP data, the program can know the size of individual incoming packets (this will be reported by the <font color="teal"><b>
'on_sock_tcp_packet_arrival </b></font>event).<br><br>
'For outgoing TCP data, no packet will be sent out at all unless entire contents of the TX buffer can be sent. Therefore, by executing 
'<font color="maroon"><b>sock.send </b></font> and waiting for <font color="maroon"><b>sock.txlen</b></font>=0 your program can make sure that 
'the packet sent will have exactly the size you needed. <br><br>
'The property is only relevant when <font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>0- NO</b></font>. With 
'inband commands enabled, the socket will always behave as if the <font color="maroon"><b>sock.splittcppackets</b></font>= <font color="olive">
'<b>0- NO</b></font>. <br><br>
'The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>sock.statesimple</b></font>
'<> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>). <br>
    get = syscall(65,"36.TDL"+) as no_yes
    set = syscall(251,"36.TDL"+) (splitpackets as no_yes)
end property

'--------------------------------------------------------------------
property sock.httpmode
'<b>PROPERTY (ENUM BYTE), DEFAULT VALUE= 0- NO (not in HTTP mode). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether this socket is in the
'HTTP mode: <font color="olive"><b>0- NO</b></font> ("regular" TCP connection), <font color="olive"><b>1- YES </b></font>(TCP HTTP connection). 
'<br><br>This property is irrelavant when the <font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>PL_SOCK_PROTOCOL_UDP
'</b></font>(UDP). If you do not set this property directly, it's value will be: <font color="olive"><b>0- NO</b></font> for all outgoing
'connections (active opens) of the socket, <font color="olive"><b>0- NO </b></font>for incoming connections received on one of the ports from 
'the <font color="maroon"><b>sock.localportlist</b></font> list, <font color="olive"><b>1- YES </b></font>for incoming connections received 
'on one of the ports from the <font color="maroon"><b>sock.httpportlist</b></font>.<br><br>
'You can manually switch any TCP connection at any time after it has been established from "regular" to HTTP by setting <font color="maroon"><b>
'sock.httpmode</b></font>=1. However, this operation is "sticky"- once you have converted the TCP connection into the HTTP mode you cannot 
'convert it back into the regular mode- trying to set <font color="maroon"><b>sock.httpmode</b></font>=0 won't have any effect- the TCP 
'connection will remain in the HTTP mode until this connection is closed. 
    get = syscall(46,"69.TDL"+) as no_yes
    set = syscall(47,"69.TDL"+) (httpmode as no_yes)
end property

'--------------------------------------------------------------------
property sock.httpnoclose
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (will be closed). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns whether TCP HTTP connection
'will be kept opened after the HTTP request has been processed and the HTML page has been sent out: <font color="olive"><b>0- NO</b></font> 
'(will be closed, standard behavior), <font color="olive"><b>1- YES </b></font>(will be kept open). <br><br>
'In the second case the end of HTML page output is marked by CR/LF/CR/LF sequence.
    get = syscall(44,"36.TDL"+) as no_yes
    set = syscall(45,"36.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
property sock.connectiontout
'<b>PROPERTY (WORD), DEFAULT VALUE= 0 (no timeout). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) sets/returns connection timeout threshold
'for the socket in half-second increments. <br><br>
'When no data is exchanged across the connection for sock.connectiontout/2 number of seconds this connection is aborted (reset for TCP and 
'discarded for UDP). Connection timeout of 0 means "no timeout".
'<br><br>
'Actual time elapsed since the last data exchange across the socket can be obtained through the
'<font color="maroon"><b>sock.toutcounter </b></font>R/O property.
    get = syscall(218,"36.TDL"+) as word
    set = syscall (219,"36.TDL"+) (connectiontout as word)
end property

'--------------------------------------------------------------------
property sock.toutcounter
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the time, in 0.5 second intervals,
'elapsed since the data was last send or received on this socket.
'<br><br>
'This property is reset to 0 each time there is some data exchanged across the socket connection.
'The property increments at 0.5 second intervals while no data is moving through this socket.
'<br><br>
'If the <font color="maroon"><b>sock.connectiontout </b></font>
'is not at 0, this property increments until it reaches the value of the
'<font color="maroon"><b>sock.connectiontout </b></font>
'and the connection is terminated.
'The <font color="maroon"><b>sock.toutcounter </b></font>
'then stays at this value.
'<br><br>
'If the <font color="maroon"><b>sock.connectiontout </b></font>
'is at 0, the maximum value that the
'<font color="maroon"><b>sock.toutcounter </b></font>
'can reach is 1. That is, the
'<font color="maroon"><b>sock.toutcounter </b></font>
'will be at 0 after the data exchange, and at 1 if at least 0.5 seconds have passed since the last data exchange.
    get = syscall(2) as word
end property

'--------------------------------------------------------------------
property sock.inbandcommands
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (inband commands disabled). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether inband command passing
'is allowed: <font color="olive"><b>0- NO</b></font> (inband commands are not allowed), <font color="olive"><b>1- YES </b></font>(inband 
'commands are allowed). <br><br>
'Inband commands are messages passedwithin the TCP data stream. Each message has to be formatted in a specific way- see the <font color="maroon">
'<b>sock.escchar </b></font> and <font color="maroon"><b>sock.endchar </b></font> properties. <br><br>
'Inband commands are not possible for UDP communications so this setting is irrelevant when <font color="maroon"><b>sock.protocol</b></font>=
'<font color="olive"><b>1- PL_SOCK_PROTOCOL_UDP</b></font>. <br><br>
'Inband messaging will work even when redirection (buffer shorting) is enabled for the socket (see the <font color="maroon"><b>sock.redir 
'</b></font>method). The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>
'sock.statesimple</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).
    get = syscall(38,"36.TDL"+) as no_yes
    set = syscall(39,"36.TDL"+) (inbandcommands as no_yes)
end property

'--------------------------------------------------------------------
property sock.escchar
'<b>PROPERTY (BYTE), DEFAULT VALUE= 255. </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the ASCII code of the 
'character that will be used as an escape character for inband commands (messages). Each inband message starts with "EC OC", where "EC" is the 
'escape character defined by the <font color="maroon"><b>sock.escchar </b></font> property and "OC" is any character other than "EC".<br><br>
'With inband commands enabled, data characters with code matching that of the escape character is transmitted as "EC EC". This property is
'irrelevant when inband commands are disabled (<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>0- NO</b></font>). '<br><br>The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>
'sock.statesimple</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).<br><br>
'See also <font color="maroon"><b>sock.endchar</b></font>.
    get = syscall(40,"36.TDL"+) as byte
    set = syscall(41,"36.TDL"+) (escchar as byte)
end property

'--------------------------------------------------------------------
property sock.endchar
'<b>PROPERTY (BYTE), DEFAULT VALUE= 13 (CR). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies the ASCII code of the 
'character that will end inband command (message). Each inband message has to end with this character, which will mark a return to the "regular"
'data stream of the TCP connection. <br><br>
'This property is irrelevant when inband commands are disabled (<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>
'0- NO</b></font>). The program won't be able to change the value of this property when the socket is not idle (<font color="maroon"><b>
'sock.statesimple</b></font><> <font color="olive"><b>0- PL_SSTS_CLOSED</b></font>). <br><br>
'See also <font color="maroon"><b>sock.escchar</b></font>.
    get = syscall(42,"36.TDL"+) as byte
    set = syscall(43,"36.TDL"+) (escchar as byte)
end property

'--------------------------------------------------------------------
property sock.gendataarrivalevent
'<b>PROPERTY (BYTE), DEFAULT VALUE= 1- YES (on_sock_data_arrival event will be generated). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) specifies whether the <font color="teal">
'<b>on_sock_data_arrival </b></font>event will be generated once there is some data in the RX buffer: <br><br>
'<font color="olive"><b>0- NO </b></font>(<font color="teal"><b>on_sock_data_arrival </b></font>event won't be generated),<br><br>
'<font color="olive"><b>1- YES </b></font>(<font color="teal"><b>on_sock_data_arrival </b></font>event will be generated).<br><br>
'Turning <font color="teal"><b>on_sock_data_arrival </b></font>event generation off may be handy when you are processing UDP datagrams 
'(<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>) in a loop while
'using the doevents. If this is the case the <font color="teal"><b>on_sock_data_arrival </b></font>event handler executed "inside" the doevents
'would "steal" datagrams from you (the datagram is deleted from the RX buffer once the <font color="teal"><b>on_sock_data_arrival
'</b></font>event handler is exited).
    get = syscall(244,"81.TDL"+) as no_yes
    set = syscall(245,"81.TDL"+) (escchar as no_yes)
end property

'--------------------------------------------------------------------
property sock.rxbuffsize
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current RX buffer capacity in
'bytes.<br><br>
'Buffer capacity can be changed through the <font color="maroon"><b>sock.rxbuffrq</b></font>. The <font color="maroon"><b>sock.rxbuffrq
'</b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.<br><br>
'Relationship between the two is as follows: <font color="maroon"><b>sock.rxbuffsize</b></font>=num_pages*256-X (or =0 when num_pages=0), 
'where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.rxbuffrq</b></font>.  "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.<br><br>
'The socket cannot RX data when the RX buffer has zero capacity.
    get = syscall(230,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.txbuffsize
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current TX buffer capacity in
'bytes. Buffer capacity can be changed through the <font color="maroon"><b>sock.txbuffrq </b></font> method followed by the 
'<font color="maroon"><b>sys.buffalloc </b></font> method.<br><br>
'The <font color="maroon"><b>sock.txbuffrq </b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.
'Relationship between the two is as follows: <font color="maroon"><b>sock.txbuffsize</b></font>=num_pages*256-X (or =0 when num_pages=0), where
'"num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.txbuffrq</b></font>. "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.<br><br>
'The socket cannot TX data when the TX buffer has zero capacity.
    get = syscall(231,"36.TDL"+) as BUFF_SIZE_TYPE
end property

#if EXTENDED_SOCK=1

'--------------------------------------------------------------------
property sock.cmdbuffsize
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current CMD buffer capacity in
'bytes.<br><br>
'Buffer capacity can be changed through the <font color="maroon"><b>sock.cmdbuffrq</b></font>. The <font color="maroon"><b>sock.rxbuffrq
'</b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.<br><br>
'Relationship between the two is as follows: <font color="maroon"><b>sock.cmdbuffsize</b></font>=num_pages*256-33 (or =0 when num_pages=0), 
'where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.cmdbuffrq</b></font>.  "-33" is because this number of bytes is needed for internal buffer
'variables.<br><br>
'The CMD buffer is only required when inband commands are enabled (sock.inbandcommands= 1-YES).
    get = syscall(631) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.rplbuffsize
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current RPL buffer capacity in
'bytes.<br><br>
'Buffer capacity can be changed through the <font color="maroon"><b>sock.rplbuffrq</b></font>. The <font color="maroon"><b>sock.rplbuffrq
'</b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.<br><br>
'Relationship between the two is as follows: <font color="maroon"><b>sock.rplbuffsize</b></font>=num_pages*256-33 (or =0 when num_pages=0), 
'where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.rplbuffrq</b></font>.  "-33" is because this number of bytes is needed for internal buffer
'variables.<br><br>
'The RPL buffer is only required when inband commands are enabled (sock.inbandcommands= 1-YES).
    get = syscall(632) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.varbuffsize
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current VAR buffer capacity in
'bytes.<br><br>
'Buffer capacity can be changed through the <font color="maroon"><b>sock.varbuffrq</b></font>. The <font color="maroon"><b>sock.varbuffrq
'</b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.<br><br>
'Relationship between the two is as follows: <font color="maroon"><b>sock.varbuffsize</b></font>=num_pages*256-33 (or =0 when num_pages=0), 
'where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.varbuffrq</b></font>.  "-33" is because this number of bytes is needed for internal buffer
'variables.<br><br>
'The VAR buffer is only required when you plan to use this socket in the HTTP mode- see sock.httpmode property, also sock.httpportlist.
    get = syscall(633) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.tx2buffsize
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns current TX2 buffer capacity in
'bytes.<br><br>
'Buffer capacity can be changed through the <font color="maroon"><b>sock.tx2buffrq</b></font>. The <font color="maroon"><b>sock.tx2buffrq
'</b></font> requests buffer size in 256-byte pages whereas this property returns buffer size in bytes.<br><br>
'Relationship between the two is as follows: <font color="maroon"><b>sock.tx2buffsize</b></font>=num_pages*256-33 (or =0 when num_pages=0), 
'where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.tx2buffrq</b></font>.  "-33" is because this number of bytes is needed for internal buffer
'variables.<br><br>
'The TX2 buffer is only required when inband commands are enabled (sock.inbandcommands= 1-YES).
    get = syscall(634) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.httprqtype
'<b>R/O PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0 (PL_SOCK_HTTP_RQ_GET). </b><br><br>
'For the currently selected socket (selection is made through sock.num), and provided that this socket is running in the HTTP mode (sock.httpmode= 1- YES),
'returns the type of the HTTP request received from the browser.
'<br><br>
'Note that it only makes sense to query this property after the HTTP request has actually been received, i.e. in the code embedded inside or called from the HTML page.
    get = syscall(465) as pl_http_rq_type
end property

#endif

'--------------------------------------------------------------------
property sock.rxlen
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns total number of bytes currently waiting
'in the RX buffer to be extracted and processed by your application. <br><br>
'The <font color="teal"><b>on_sock_data_arrival </b></font>event is generated once the RX buffer is not empty, i.e. there is data to process. 
'There may be only one <font color="teal"><b>on_sock_data_arrival </b></font>event for each socket waiting to be processed in the event queue.
'<br><br>Another <font color="teal"><b>on_sock_data_arrival </b></font>event for the same socket may be generated only after the previous one 
'is handled. If, during the <font color="teal"><b>on_sock_data_arrival </b></font>event handler execution, not all data is extracted from the 
'RX buffer, another <font color="teal"><b>on_sock_data_arrival </b></font>event is generated immediately after the <font color="teal"><b>
'on_sock_data_arrival </b></font>event handler is exited.
    get = syscall(232,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.txlen
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the total number of bytes 
'currently found in the TX buffer (including the uncommitted data).<br><br>
'Your application may use the <font color="maroon"><b>sock.notifysent </b></font>method to get <font color="teal"><b>on_sock_data_sent
'</b></font>event once the total number of committed bytes in the TX buffer drops below the level defined by the <font color="maroon"><b>
'sock.notifysent</b></font> method. <br><br>
'See also <font color="maroon"><b>sock.newtxlen</b></font>.
    get = syscall(233,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.txfree
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE=0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the amount of free space in the TX 
'buffer in bytes. Sock.txfree = sock.txbufflen - sock.txlen.<br><br>
'Your application will not be able to store more data than this amount. To achieve asynchronous data processing, use the <font color="maroon">
'<b>sock.notifysent</b></font> method to get <font color="teal"><b>on_sock_data_sent</b></font> event once the TX buffer gains required 
'amount of free space.
    get = syscall(235,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.newtxlen
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the amount of uncommitted TX data in 
'bytes. Uncommitted data is the one that was added to the TX buffer with the <font color="maroon"><b>sock.setdata </b></font> method but not 
'yet committed using the <font color="maroon"><b>sock.send </b></font>method.
    get = syscall(242) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.httprqstring
'<b>R/O PROPERTY (STRING), DEFAULT VALUE= "". </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns up to 255 bytes of the HTTP
'request string stored in the VAR buffer.
'<br><br>
'The <font color="maroon"><b>sock.httprqstring </b></font>
'is a property; it can be invoked several times and will return the same data (when the property is used the data is not deleted from the VAR buffer).
'<br><br>
'This property is only relevant when the socket is in the HTTP mode
'(<font color="maroon"><b>sock.httpmode</b></font>=
'<font color="olive"><b>1- YES</b></font>).
'Use it from within an HTML page or
'<font color="teal"><b>on_sock_postdata </b></font>
'event handler.
'Maximum length of data that can be obtained through this property is 255 bytes,
'since this is the maximum possible capacity of a string variable that will accept the value of this property.
'<br><br>
'Rely on the
'<font color="teal"><b>on_sock_postdata </b></font>
'event and the
'<font color="maroon"><b>sock.gethttprqstring </b></font>
'method to handle large amounts of HTTP variable data correctly.
    get = syscall(188,"36.TDL"+) as string
end property

'--------------------------------------------------------------------
syscall(556,"36.TDL") sock.gethttprqstring(maxinplen as word) as string
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) extracts up to 255 bytes of the HTTP
'request string from the VAR buffer.
'<br><br>
'Extracted data is permanently deleted from the VAR buffer.
'Length of extracted data is limited by one of the three factors (whichever is smaller):
'amount of data in the buffer itself, capacity of the "receiving" string variable, and the limit set by the maxinplen argument.
'<br><br>
'This method is only relevant when the socket is in the HTTP mode
'(<font color="maroon"><b>sock.httpmode</b></font>=
'<font color="olive"><b>1- YES</b></font>).
'Use it from within an HTML page or
'<font color="teal"><b>on_sock_postdata </b></font>
'event handler.
'<br><br>
'See also: <font color="maroon"><b>sock.httprqstring</b></font>.

'--------------------------------------------------------------------
property sock.rxpacketlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the length (in bytes) of the UDP 
'datagram being extracted from the RX buffer. This property is only relevant when the <font color="maroon"><b>sock.protocol</b></font>= 
'<font color="olive"><b>1-PL_SOCK_PROTOCOL_UDP</b></font>. <br><br>
'Correct way of using this property is within the <font color="teal"><b>on_sock_data_arrival </b></font>event or in conjunction with the
'<font color="maroon"><b>sock.nextpacket</b></font> method.<br><br> 
'See also <font color="maroon"><b>sock.rxlen </b></font> property.
    get = syscall(241) as word
end property

'--------------------------------------------------------------------
property sock.cmdlen
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the length of data (in bytes) waiting
'to be processed in the CMD buffer. This buffer accumulates incoming inband commands (messages) and may contain more than one such command.
'Use <font color="maroon"><b>sock.getinband </b></font> method to extract the data from the CMD buffer. <br><br>
'See also <font color="maroon"><b>sock.rpllen </b></font> and <font color="maroon"><b>sock.inbandcommands</b></font>.
    get = syscall(96,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.varlen
'<b>R/O PROPERTY (WORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the length of data (in bytes) waiting
'to be processed in the VAR buffer. This buffer accumulates incoming HTTP request string.
'Use <font color="maroon"><b>sock.gethttprqstring </b></font> method to extract the data from the CMD buffer. <br><br>
    get = syscall(95,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.rpllen
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the length of data (in bytes) waiting
'to be send out from the RPL buffer; this is the buffer that keeps outgoing inband replies (messages). <br><br>
'Your application adds inband replies to the RPL buffer with the <font color="maroon"><b>sock.setsendinband </b></font> method. Several 
'inband replies may be waiting in the RPL buffer.<br><br>
'See also <font color="maroon"><b>sock.cmdlen</b></font>, <font color="maroon"><b>sock.rplfree </b></font> and <font color="maroon"><b>
'sock.inbandcommands</b></font>.
    get = syscall(97,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.rplfree
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the free space (in bytes) available in
'the RPL buffer; this is the buffer that stores outgoing inband replies (messages). <br><br>
'Your application adds inband replies to the RPL buffer with the <font color="maroon"><b>sock.setsendinband </b></font> method. Several inband
'replies may be waiting in the RPL buffer.<br><br>
'See also <font color="maroon"><b>sock.cmdlen</b></font>, <font color="maroon"><b>sock.rpllen </b></font> and <font color="maroon"><b>
'sock.inbandcommands</b></font>.
    get = syscall(99,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
property sock.tx2len
'<b>R/O PROPERTY (WORD | DWORD), DEFAULT VALUE= 0 (0 bytes). </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the amount of data waiting to be sent
'out in the TX2 buffer; this is the buffer that is needed to transmit outgoing TCP data when inband commands (messages) are enabled
'(<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>1- YES</b></font>).<br><br>
'If your application needs to make sure that all data is actually sent out then it must verify that both TX and TX2 buffers are empty.<br><br>
'See also <font color="maroon"><b>sock.txlen</b></font> and <font color="maroon"><b>sock.txfree</b></font>.
    get = syscall(98,"36.TDL"+) as BUFF_SIZE_TYPE
end property

'--------------------------------------------------------------------
syscall(236) sock.rxclear()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) clears (deletes all data from) the RX buffer.
'Invoking this method will have no effect when the socket is in the HTTP mode (<font color="maroon"><b>sock.httpmode</b></font>= 
'<font color="olive"><b>1- YES</b></font>).

'--------------------------------------------------------------------
syscall(237) sock.txclear()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) clears (deletes all data from) the TX buffer.
'Invoking this method will have no effect when the socket is not idle (<font color="maroon"><b>sock.statesimple</b></font><> 
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>).

'--------------------------------------------------------------------
syscall(238) sock.getdata(maxinplen as word) as string
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the string that contains the data
'extracted from the RX buffer. Extracted data is permanently deleted from the buffer. <br><br>
'Length of extracted data is limited by one of the three factors (whichever is smaller): amount of data in the RX buffer itself, capacity of 
'the "receiving" string variable, and the limit set by the maxinplen argument.<br><br>
'Additionally, if this socket uses UDP transport protocol (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>
'1-PL_SOCK_PROTOCOL_TCP</b></font>) the length of data that will be extracted is limited to the UDP datagram being processed. <br><br>
'Additional conditions apply to UDP datagram processing; see <font color="teal"><b>on_sock_data_arrival </b></font>event and 
'<font color="maroon"><b>sock.nextpacket </b></font> method.

'--------------------------------------------------------------------
syscall(14) sock.peekdata(maxinplen as word) as string
'METHOD.
'For the selected socket (selection is made through sock.num) returns the string that contains the "preview" of the data
'from the RX buffer. The data is NOT deleted from the buffer. For TCP (sock.protocol= 1- PL_SOCK_PROTOCOL_UDP) the length of returned data is
'limited by one of the three factors (whichever is smaller): amount of data in the RX buffer itself, capacity of the
'"receiving" string variable, and the limit set by the maxinplen argument. String variables can hold up to 255 bytes of data, so this
'method will only allow you to preview up to 255 "next" bytes from the RX buffer.
'For UDP (sock.protocol= 0- PL_SOCK_PROTOCOL_UDP), additional limitations apply. The "current" UDP datagram is always deleted automatically
'when the on_sock_data_arrival event is exited. This means that you will "lose" this datagram from the buffer upon exiting the
'on_sock_data_arrival event even if your program only used sock.peekdata. Also, the amount of data returned by the sock.peekdata is
'limited to the "next" UDP datagram waiting in the RX buffer.
'See on_sock_data_arrival event and sock.nextpacket methods for additional info. See also: sock.getdata method.

'--------------------------------------------------------------------
syscall(239) sock.setdata(byref txdata as string)
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) adds the data passed in the txdata argument to
'the contents of the TX buffer. If the buffer doesn't have enough space to accommodate the data being added then this data will be truncated. 
'Newly saved data is not sent out immediately. This only happens after the <font color="maroon"><b>sock.send</b></font> method
'is used to commit the data. This allows your application to prepare large amounts of data before sending it out.<br><br>
'Total amount of newly added (uncommitted) data in the buffer can be checked through the <font color="maroon"><b>sock.newtxlen </b></font> 
'setting. <br><br>
'Also see <font color="maroon"><b>sock.txlen</b></font>, <font color="maroon"><b>sock.txfree</b></font>, <font color="maroon"><b>
'sock.notifysent</b></font>, and <font color="teal"><b>on_sock_data_sent</b></font>.

'--------------------------------------------------------------------
syscall(240) sock.send()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) commits (allows sending) the data that was
'previously saved into the TX buffer using the <font color="maroon"><b>sock.setdata </b></font> method. <br><br>
'You can monitor the sending progress by checking the <font color="maroon"><b>sock.txlen</b></font> property or using the 
'<font color="maroon"><b>sock.notifysent</b></font> method and the <font color="teal"><b>on_sock_data_sent</b></font> event. 

'--------------------------------------------------------------------
syscall(50,"36.TDL"+) sock.getinband as string
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) returns the string that contains the data
'extracted from the CMD buffer; this is the buffer that accumulates inband commands. <br><br>
'Extracted data is permanently deleted from the CMD buffer. Length of extracted data is limited by one of the two factors (whichever is 
'smaller): amount of data in the CMD buffer itself, and the capacity of the "receiving" buffer variable. <br><br>
'Several inband commands may be waiting in the CMD buffer. Each command will always be complete, i.e. there will be no situation when you
'will extract a portion of the command because the end of this command hasn't arrived yet. <br><br>
'Inband commands stored in the CMD buffer will have escape character (see <font color="maroon"><b>sock.escchar </b></font> property) and the 
'next character after the escape character already cut off, but the end character (see <font color="maroon"><b>sock.endchar </b></font> 
'property) will still be present. Therefore, your application can separate inband command from each other by finding end characters.

'--------------------------------------------------------------------
syscall(427,"36.TDL"+) sock.peekinband as string
'METHOD.
'For the selected socket (selection is made through sock.num) returns the string that contains the "preview" of the data from
'the CMD buffer; this is the buffer that accumulates inband commands. The data is NOT deleted from the
'CMD buffer. Length of extracted data is limited by one of the two factors (whichever is smaller):
'amount of data in the CMD buffer itself, and the capacity of the "receiving" buffer variable. String variables can hold up
'to 255 bytes of data, so this method will only allow you to preview up to 255 "next" bytes from the RX buffer.
'Several inband commands may be waiting in the CMD buffer. Commands stored in the CMD buffer will have escape character
'(see sock.escchar property) and the next character after the escape character already cut off, but the end character
'(see sock.endchar property) will still be present. Therefore, your application can separate inband command from each other by
'finding end characters. Internally, the CMD buffer always stores complete commands. The sock.peekinband method only allows you
'to preview "next" 255 bytes of the buffer contents, therefore, the preview of the data may contain a partial command.
'See also: sock.getinband method. 

'--------------------------------------------------------------------
syscall(51,"36.TDL"+) sock.setsendinband(byref data as string)
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) puts the data into the RPL buffer; this is the
'buffer that stores outgoing inband replies (messages). This method also commits the newly stored data. This is different from the
'TX buffer for which two separate methods- <font color="maroon"><b>sock.setdata </b></font> and <font color="maroon"><b>sock.send</b></font>- 
'are used to store and commit the data. <br><br>
'It is the responsibility of your application to properly encapsulate outgoing messages with escape sequence ("EC OC", see the 
'<font color="maroon"><b>sock.escchar </b></font> property) and the end character (see the <font color="maroon"><b>sock.endchar </b></font>
'property). <br><br>
'When adding the data to the RPL buffer make sure you are adding entire inband message at once- you are not allowed to do this "in portions"!

'--------------------------------------------------------------------
syscall(243) sock.notifysent(threshold as word)
'<b>METHOD. </b><br><br>
'Using this method for the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) will cause the 
'<font color="teal"><b>on_sock_data_sent </b></font>event to be generated when the amount of committed data in the TX buffer is found to be 
'equal or below "threshold" number of bytes.<br><br>
'Only one <font color="teal"><b>on_sock_data_sent </b></font>event will be generated each time after the <font color="maroon"><b>
'sock.notifysent</b></font> is invoked. <br><br>
'This method, together with the <font color="teal"><b>on_sock_data_sent </b></font>event provides a way to handle data sending asynchronously.
'Just like with <font color="maroon"><b>sock.txfree</b></font>, the trigger you set won't take into account any uncommitted data in the TX 
'buffer.

'--------------------------------------------------------------------
syscall(189) sock.nextpacket()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) in the UDP mode (<font color="maroon"><b>
'sock.protocol</b></font>= <font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>) closes processing of current UDP datagram and moves to 
'the next datagram. <br><br>
'For UDP, the <font color="maroon"><b>sock.getdata </b></font>method only extracts the data from a single UDP datagram even if several 
'datagrams are stored in the RX buffer. When incoming UDP datagram processing is based on the <font color="teal"><b>on_sock_data_arrival
'</b></font>event the use of the <font color="maroon"><b>sock.nextpacket </b></font> is not required since each invocation of the 
'<font color="teal"><b>on_sock_data_arrival </b></font>event handler "moves" processing to the next UDP datagram.<br><br>
'The method is useful when it is necessary to move to the next datagram without re-entering <font color="teal"><b>on_sock_data_arrival
'</b></font>. Therefore, <font color="maroon"><b>sock.nextpacket </b></font> is only necessary when the application needs to process
'several incoming UDP packets at once and within a single event handler.

'--------------------------------------------------------------------
syscall(226) sock.connect()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to attempt to connect to 
'the target host specified by the <font color="maroon"><b>sock.targetport</b></font> and <font color="maroon"><b>sock.targetip</b></font>
'(unless, for UDP, the socket is to broadcast the data- see the <font color="maroon"><b>sock.targetbcast </b></font> property).
'<br><br>
'Outgoing connection will be attempted through the network interface defined by the
'<font color="maroon"><b>sock.targetinterface </b></font>
'property.
'<br><br>
'Method invocation will have effect only if connection was closed at the time when the method was called (<font color="maroon"><b>sock.state
'</b></font> in one of <font color="olive"><b>PL_SST_CLOSED </b></font> states). 

'--------------------------------------------------------------------
syscall(227) sock.close()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to close the connection 
'with the other host. <br><br>
'For established TCP connections this will be a "graceful disconnect", if the TCP connection was in the "connection opening" or "connection
'closing" state this will be a reset (just like when the <font color="maroon"><b>sock.reset </b></font> method is used).<br><br>
'If connection was in the ARP phase or the transport protocol was UDP (<font color="maroon"><b>sock.protocol</b></font>= 0- 
'<font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>) the connection will be discarded (just like when the <font color="maroon"><b>
'sock.discard </b></font> method is used). <br><br>
'Method invocation will have NO effect if connection was closed at the time when the method was called (<font color="maroon"><b>sock.state
'</b></font>in one of <font color="olive"><b>PL_SST_CLOSED </b></font> states).

'--------------------------------------------------------------------
syscall(228) sock.reset()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to abort the connection with
'the other host. <br><br>
'For TCP connections that were established, being opened, or being closed this will be a reset (RST will be sent to the other end of the 
'connection).<br><br>
'If connection was in the ARP phase or the transport protocol was UDP (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive">
'<b>0- PL_SOCK_PROTOCOL_UDP</b></font>) the connection will be discarded (just like when the <font color="maroon"><b>sock.discard </b></font>
'method is used). <br><br>
'Method invocation will have NO effect if connection was closed at the time when the method was called (<font color="maroon"><b>
'sock.state</b></font> in one of <font color="olive"><b>PL_SST_CLOSED </b></font> states). <br><br>
'See also <font color="maroon"><b>sock.close </b></font> method.

'--------------------------------------------------------------------
syscall(229) sock.discard()
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) causes the socket to discard the connection 
'with the other host. Discarding the connection means simply forgetting about it without notifying the other side of the connection
'in any way. <br><br>
'See also <font color="maroon"><b>sock.close </b></font> and <font color="maroon"><b>sock.reset </b></font> methods.

'--------------------------------------------------------------------
syscall(89,"35.TDL") sock.rxbuffrq(numpages as BUFF_PAGE_TYPE) as BUFF_PAGE_TYPE
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the RX buffer of the socket. Returns actual number of pages that can be allocated.<br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. The socket is unable to RX data if its RX
'buffer has 0 capacity. Actual current buffer capacity can be checked through the <font color="maroon"><b>sock.rxbuffsize </b></font> which
'returns buffer capacity in bytes. Relationship between the two is as follows:<br><br>
'<font color="maroon"><b>sock.rxbuffsize</b></font>=num_pages*256-X (or =0 when num_pages=0), where "num_pages" is the number of buffer pages
'that was GRANTED through the <font color="maroon"><b>sock.rxbuffrq</b></font>. "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.
'<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.
'<br><br>
'<b>On the EM2000 and other 32-bit platforms, the maximum number of pages you can request for one buffer is limited to 255.</b>
'<br><br>
'See also <font color="maroon"><b>sock.txbuffrq </b></font> method.

'--------------------------------------------------------------------
syscall(90,"35.TDL") sock.txbuffrq(numpages as BUFF_PAGE_TYPE) as BUFF_PAGE_TYPE
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the TX buffer of the socket. Returns actual number of pages that can be allocated.<br><bR>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font>method is used. The socket is unable to TX data if its TX 
'buffer has 0 capacity. Actual current buffer capacity can be checked through the <font color="maroon"><b>sock.txbuffsize </b></font> which
'returns buffer capacity in bytes. Relationship between the two is as follows: <br><br>
'<font color="maroon"><b>sock.txbuffsize</b></font>=num_pages*256-X (or =0 when num_pages=0), where "num_pages" is the number of buffer pages
'that was GRANTED through the <font color="maroon"><b>sock.txbuffrq</b></font>. "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.
'<br><br>
'<b>On the EM2000 and other 32-bit platforms, the maximum number of pages you can request for one buffer is limited to 255.</b>
'<br><br>
'See also <font color="maroon"><b>sock.tx2buffrq </b></font> method.

'--------------------------------------------------------------------
syscall(91,"35.TDL") sock.cmdbuffrq(numpages as BUFF_PAGE_TYPE) as BUFF_PAGE_TYPE
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the CMD buffer of the socket; this is the buffer that accumulates incoming inband commands (messages). Returns actual 
'number of pages that can be allocated. <br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. The socket is unable to receive inband
'commands if its CMD buffer has 0 capacity.<br><br>
'Unlike for TX or RX buffers there is no property to read out actual CMD buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-X (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>sock.cmdbuffrq</b></font>. 
' "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.
'<br><br>
'<b>On the EM2000 and other 32-bit platforms, the maximum number of pages you can request for one buffer is limited to 255.</b>
'<br><br>
'See also <font color="maroon"><b>sock.rplbuffrq </b></font> method.

'--------------------------------------------------------------------
syscall(92,"35.TDL") sock.rplbuffrq(numpages as BUFF_PAGE_TYPE) as BUFF_PAGE_TYPE
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the RPL buffer of the socket; this is the buffer that stores outgoing inband replies (messages). Returns actual number
'of pages that can be allocated.<br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font>method is used. The socket is unable to send inband replies
'if its RPL buffer has 0 capacity.<br><br>
'Unlike for TX or RX buffers there is no property to read out actual RPL buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-X (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon">
'<b>sock.rplbuffrq</b></font>.  "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.
'<br><br>
'<b>On the EM2000 and other 32-bit platforms, the maximum number of pages you can request for one buffer is limited to 255.</b>
'<br><br>
'See also <font color="maroon"><b>sock.cmdbuffrq </b></font> method.

'--------------------------------------------------------------------
syscall(93,"35.TDL") sock.varbuffrq(numpages as BUFF_PAGE_TYPE) as BUFF_PAGE_TYPE
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the VAR buffer of the socket; this is the buffer that stores the HTTP request string. Returns actual number of pages 
'that can be allocated. <br><br>
'Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font> method is used. The socket is unable to receive HTTP 
'request string if its VAR buffer has 0 capacity. <br><br>
'Unlike for TX or RX buffers there is no property to read out actual VAR buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-X (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the sock.varbuffrq. 
' "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.
'<br><br>
'<b>On the EM2000 and other 32-bit platforms, the maximum number of pages you can request for one buffer is limited to 255.</b>
'<br><br>
'The VAR buffer is only required when you plan to use this socket in the HTTP mode- see <font color="maroon"><b>sock.httpmode</b></font> 'roperty, also <font color="maroon"><b>sock.httpportlist</b></font>.

'--------------------------------------------------------------------
syscall(94,"35.TDL") sock.tx2buffrq(numpages as BUFF_PAGE_TYPE) as BUFF_PAGE_TYPE
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) pre-requests "numpages" number of buffer pages
'(1 page= 256 bytes) for the TX2 buffer of the socket; this buffer is required when inband commands are enabled (<font color="maroon"><b>
'sock.inbandcommands</b></font>= <font color="olive"><b>1- YES</b></font>), without it the socket won't be able to TX data. <br><br>
'Returns actual number of pages that can be allocated. Actual allocation happens when the <font color="maroon"><b>sys.buffalloc </b></font>
'method is used.<br><br>
'Unlike for TX or RX buffers there is no property to read out actual TX2 buffer capacity in bytes. This capacity can be calculated as 
'num_pages*256-X (or =0 when num_pages=0), where "num_pages" is the number of buffer pages that was GRANTED through the <font color="maroon"><b>
'sock.tx2buffrq</b></font>. "-X" is because a number of bytes is needed for internal buffer
'variables. X=17 on 16-bit platforms and 33 on 32-bit platforms.<br><br>
'Buffer allocation will not work if the socket to which this buffer belongs is not idle (<font color="maroon"><b>sock.statesimple</b></font><>
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>) at the time when <font color="maroon"><b>sys.buffalloc </b></font> executes. You can only change 
'buffer sizes of sockets that are closed.
'<br><br>
'<b>On the EM2000 and other 32-bit platforms, the maximum number of pages you can request for one buffer is limited to 255.</b>

'--------------------------------------------------------------------
syscall(81,"24.TDL") sock.redir(redir as pl_redir) as pl_redir
'<b>METHOD. </b><br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) redirects the data being RXed to the TX buffer
'of the same socket, different socket, or another object that supports compatible buffers.<br><br>
'The redir argument, as well as the value returned by this method are of "<font color="olive"><b>enum pl_redir</b></font>" type. The 
'<font color="olive"><b>pl_redir </b></font>defines a set of inter-object constants that include all possible redirections for this platform.
'Specifying redir value of <font color="olive"><b>0- PL_REDIR_NONE </b></font> cancels redirection.<br><br>
'This method returns actual redirection result: <font color="olive"><b>0- PL_REDIR_NONE </b></font>if redirection failed or the
'same value as the one that was passed in the redir argument if redirection was successful.

'--------------------------------------------------------------------
property sock.inconenabledmaster
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 1- YES (incoming connections are globally enabled). </b><br><br>
'A master switch that globally defines whether incoming connections will be accepted: <font color="olive"><b>0- NO </b></font>(no socket will be
'allowed to accept an incoming connection), <font color="olive"><b>1- YES </b></font>(incoming connections are globally enabled; individual 
'socket's behavior and whether it will accept or reject a particular incoming connection depends on the setup of this socket).<br><br>
'This property can be used to temporarily disable incoming connection acceptance on all sockets without changing individual setup of each socket.
    get = syscall(186,"39.TDL"+) as no_yes
    set= syscall(225,"39.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
property sock.urlsubstitutes
'<b>PROPERTY (STRING), DEFAULT VALUE= "" (no substitutes set). </b><br><br>
'A comma-separated list of filenames whose extensions will be automatically substituted for <i>.html </i>by the internal webserver of your device.
'Max string length for this property is 40 bytes.
'<br><br>
'The substitution will be used only if the resource file with the requested file name is not included in the project directly.
'<br><br>
'For example, setting this property to <i>pix1.bmp </i>will force the webserver to actually process <i>pix1.html</i>, but only if the file
'<i>pix1.bmp </i>is not found.
'Data output by the webserver to the browser will still look like a <i>.bmp </i>file.
'For this to work, the <i>pix1.html </i>must exist in the project.
'<br><br>
'This property allows programmatic generation of non-HTML files. In the above example it is possible to generate the BMP file through a
'BASIC code. There is no other way to do this, since only HTML files are parsed for BASIC code inclusions.
    get = syscall(541) as string
    set= syscall(542) (byref value as string)
end property

'--------------------------------------------------------------------
property sock.sinkdata
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- NO (normal data processing). </b><br><br>
'For the currently selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>)
'specifies whether the incoming data should be discarded.
'<br><br>
'Setting this property to
'<font color="olive"><b>1- YES </b></font>
'causes the socket to automatically discard all incoming data without passing it to your application.
'<br><br>
'The <font color="teal"><b>on_sock_data_arrival </b></font>
'event will not be generated, reading
'<font color="maroon"><b>sock.rxlen </b></font>
'will always return zero, and so on. No data will be reaching its destination even in case of buffer redirection
'(see <font color="maroon"><b>sock.redir</b></font>).
'<br><br>
'Inband commands
'(see <font color="maroon"><b>sock.unband</b></font>)
'will still be extracted from the incoming data stream and processed.
'<font color="maroon"><b>Sock.connectiontout </b></font>and
'<font color="maroon"><b>sock.toutcounter </b></font>
'will work correctly as well. 
    get = syscall(3,"36.TDL"+) as no_yes
    set= syscall(4,"36.TDL"+) (value as no_yes)
end property

'--------------------------------------------------------------------
property sock.allowedinterfaces
'<b>PROPERTY (STRING), DEFAULT VALUE is platform-dependent.</b>
'<br><br>
'For the selected socket (selection is made through <font color="maroon"><b>sock.num</b></font>) defines the list of network interfaces on which
'this socket will accept incoming connections.
'<br><br>
'Interfaces that can be on the list are: "NET" (Ethernet), "WLN" (Wi-Fi), "PPP", and "PPPoE".
'The list of allowed interfaces is comma-delimited, i.e. "WLN,NET".
'<br><br>
'Note that reading back the value of this property may not necessarily return the items in the same order as they were set.
'For example, the application may write "WLN,NET" into this property, yet read "NET,WLN" back. Unsupported interface
'names will be dropped from the list automatically.
'<br><br>
'The list of interfaces supported by your platform can be checked through
'<font color="maroon"><b>sock.availableinterfaces</b></font>.
'Only interfaces from this list can be specified as "allowed". Trying to allow an unsopported interface will not work.
'<br><br>
'See also:
'<font color="maroon"><b>sock.targetinterface</b></font>,
'<font color="maroon"><b>sock.currentinterface</b></font>.
    get = syscall(532,"73.TDL"+) as string
    set = syscall(533,"73.TDL"+) (byref interface as string)
end property

'--------------------------------------------------------------------
property sock.availableinterfaces
'<b>R/O PROPERTY (WORD). </b><br><br>
'Returns the comma-delimited list of network interfaces available on this platform.
'<br><br>
'This list may possibly include: "NET" (Ethernet), "WLN" (Wi-Fi), "PPP", and "PPPoE".
'Different platforms support a different set of interfaces.
'<br><br>
'See also:
'<font color="maroon"><b>sock.targetinterface</b></font>,
'<font color="maroon"><b>sock.currentinterface</b></font>,
'<font color="maroon"><b>sock.allowedinterfaces</b></font>.
    get = syscall(557,"73.TDL"+) as string
end property

'--------------------------------------------------------------------
property sock.targetinterface
'<b>PROPERTY (ENUM, BYTE), DEFAULT VALUE= 1- PL_SOCK_INTERFACE_NET</b>.
'<br><br>
'For the selected socket (selection is made through
'<font color="maroon"><b>sock.num</b></font>)
'selects the network interface through which an outgoing connection will be established.
'<br><br>
'The list of possible values reflects the set of interfaces available on the selected platform.
'There is always one extra item on the list -- NULL interface. As the name implies, this is not an empty interface.
'Connection cannot be made on it.
'<br><br>
'See also:
'<font color="maroon"><b>sock.availableinterfaces</b></font>,
'<font color="maroon"><b>sock.currentinterface</b></font>,
'<font color="maroon"><b>sock.allowedinterfaces</b></font>.
    get = syscall(530,"73.TDL"+) as pl_sock_interfaces
    set = syscall(531,"73.TDL"+) (interface as pl_sock_interfaces)
end property

'--------------------------------------------------------------------
property sock.currentinterface
'<b>R/O PROPERTY (ENUM, BYTE), DEFAULT VALUE= 0- PL_SOCK_INTERFACE_NULL</b>.
'<br><br>
'For the selected socket (selection is made through
'<font color="maroon"><b>sock.num</b></font>)
'returns the network interface this socket is currently communicating through.
'<br><br>
'The list of possible values reflects the set of interfaces available on the selected platform.
'There is always one extra item on the list -- NULL interface. It means that the socket hasn't been engaged in any connection yet.
'<br><br>
'The value of this property is only valid when the socket is not idle, i.e.
'<font color="maroon"><b>sock.statesimple </b></font>
'is not equal to
'<font color="olive"><b>0- PL_SSTS_CLOSED</b></font>.
'<br><br>
'See also:
'<font color="maroon"><b>sock.availableinterfaces</b></font>,
'<font color="maroon"><b>sock.targetinterface</b></font>,
'<font color="maroon"><b>sock.allowedinterfaces</b></font>.
    get = syscall(534,"73.TDL"+) as pl_sock_interfaces
end property

'--------------------------------------------------------------------
event(3)  on_sock_inband
'<b>EVENT of the sock object. </b><br><br>
'At least one data byte is present in the CMD buffer (<font color="maroon"><b>sock.cmdlen</b></font>>0). Use the <font color="maroon"><b>
'sock.getinband </b></font> method to extract the data from the CMD buffer. <br><br>
'Another <font color="teal"><b>on_inband_command </b></font>event on a particular socket is never generated until the previous 
'one is processed. When the event handler is entered the <font color="maroon"><b>sock.num </b></font>is automatically switched to the 
'socket on which this event was generated. 

'--------------------------------------------------------------------
event(24)  on_sock_postdata
'<b>EVENT of the sock object. </b><br><br>
'Generated when at least one data byte is present in the VAR buffer of the socket,
'but only after the VAR buffer has become full at least once in the cause of the current HTTP request processing.
'<br><br>
'Two same-socket <font color="teal"><b>on_sock_postdata </b></font>events never wait in the queue -- the next event can only be generated after the previous one is processed.
'<br><br>
'Use the
'<font color="maroon"><b>sock.gethttprqstring </b></font>
'method or
'<font color="maroon"><b>sock.httprqstring </b></font>
'property to work with the VAR buffer's data.

'--------------------------------------------------------------------
event(4)  on_sock_data_arrival
'<b>EVENT of the sock object. </b><br><br> 
'Generated when at least one data byte is present in the RX buffer of the socket (i.e. for this socket the <font color="maroon"><b>
'sock.rxlen</b></font>>0). When the event handler for this event is entered the <font color="maroon"><b>sock.num </b></font>property is
'automatically switched to the socket for which this event was generated.<br><br>
'Another <font color="teal"><b>on_sock_data_arrival </b></font>event on a particular socket is never generated until the previous 
'one is processed. Use <font color="maroon"><b>sock.getdata </b></font>method to extract the data from the RX buffer.<br><br>
'For TCP protocol (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>1- PL_SOCK_PROTOCOL_TCP</b></font>), there is 
'no separation into individual packets and you get all arriving data as a "stream". You don't have to process all data in the RX buffer at 
'once. If you exit the <font color="teal"><b>on_sock_data_arrival </b></font>event handler while there is still some unprocessed 
'data in the RX buffer another <font color="teal"><b>on_sock_data_arrival </b></font>event will be generated immediately.<br><br>
'For UDP protocol (<font color="maroon"><b>sock.protocol</b></font>= <font color="olive"><b>0- PL_SOCK_PROTOCOL_UDP</b></font>), the RX 
'buffer preserves datagram boundaries. Each time you enter the <font color="teal"><b>on_sock_data_arrival </b></font>event handler
'you get to process next UDP datagram. If you do not process entire datagram contents the unread portion of the datagram is discarded once 
'you exit the event handler.<br><br>
'This event is not generated for a particular socket when buffer redirection is set for this socket through the <font color="maroon"><b>
'sock.redir </b></font>method.

'--------------------------------------------------------------------
event(5)  on_sock_event(newstate as pl_sock_state,newstatesimple as pl_sock_state_simple)
'<b>EVENT of the sock object. </b><br><br> 
'Notifies your program that the socket state has changed.
'<br><br>
'The newstate and newstatesimple arguments carry the state as it was at the moment of event generation.
'This is different from
'<font color="maroon"><b>sock.state </b></font>and
'<font color="maroon"><b> sock.statesimple</b></font>
'R/O properties that return current socket state.
'<br><br>
'See <font color="olive"><b>pl_sock_state </b></font>and
'<font color="olive"><b>pl_sock_state_simple </b></font>
'constants for description of reported socket states.
'<br><br>
'Multiple
'<font color="olive"><b>on_sock_event </b></font>
'events may be waiting in the event queue. For this reason the doevents statement will be skipped (not executed) if encountered within the event handler
'for this event or the body of any procedure in the related call chain.

'--------------------------------------------------------------------
event(6)  on_sock_overrun
'<b>EVENT of the sock object. </b><br><br> Data overrun has occurred in the RX buffer of the socket. Normally, this can only happen
'for UDP communications as UDP has no "data flow control" and, hence, data overruns are normal.
'<br><br>
'Another <font color="teal"><b>
'on_sock_overrun </b></font>event on a particular socket is never generated until the previous one is processed.
'<br><br>
'When event handler for this event is entered the <font color="maroon"><b>sock.num  </b></font>is automatically switched to the socket on 
'which this event was generated.
 
'--------------------------------------------------------------------
event(13) on_sock_data_sent
'<b>EVENT of the sock object. </b><br><br> 
'Generated after the total amount of committed data in the TX buffer of the socket (<font color="maroon"><b>sock.txlen</b></font>) is
'found to be less than the threshold that was preset through the <font color="maroon"><b>sock.notifysent </b></font>method. This event may
'be generated only after the <font color="maroon"><b>sock.notifysent</b></font> method was used. <br><br>
'Your application needs to use the <font color="maroon"><b>sock.notifysent</b></font> method EACH TIME it wants to cause the 
'<font color="teal"><b>on_sock_data_sent </b></font>event generation for a particular socket. <br><br>
'When the event handler for this event is entered the <font color="maroon"><b>sock.num  </b></font>is automatically switched to the port on
'which this event was generated. Please, remember that uncommitted data in the TX buffer is not taken into account for the 
'<font color="teal"><b>on_sock_data_sent </b></font>event generation.

'--------------------------------------------------------------------
event(18)  on_sock_tcp_packet_arrival(len as word)
'<b>EVENT of the sock object. </b><br><br> 
'Notifies your program that the TCP packet of a certain size has arrived.
'<br><br>
'The len argument carries packet length. This event is only generated when
'<font color="maroon"><b>sock.splittcppackets</b></font>= <font color="olive"><b>1- YES </b></font>and
'<font color="maroon"><b>sock.inbandcommands</b></font>= <font color="olive"><b>0- DISABLED</b></font>.
'<br><br>
'Notice that only new data, never transmitted before, is counted. If the packet is a retransmission then this event won't be generated. Also,
'if some part of packet's data is a retransmission and some part is new then only the length of the new data will be reported. This way your
'program can maintain correct relationship between data lengths reported by this event and actual data in the RX buffer.
'<br><br>
'Multiple
'<font color="olive"><b>on_sock_tcp_packet_arrival </b></font>
'events may be waiting in the event queue. For this reason the doevents statement will be skipped (not executed) if encountered within the event handler
'for this event or the body of any procedure in the related call chain.

'--------------------------------------------------------------------
syscall(637) !sock.gettxdata(maxinplen as word) as string
syscall(638) !sock.setcommitrxdata(byref txdata as string)
syscall(639) !sock.setcommitcmddata(byref txdata as string)
syscall(640) !sock.getrpldata(maxinplen as word) as string
syscall(641) !sock.setcommitvardata(byref txdata as string)
syscall(642) !sock.setcommittx2data(byref txdata as string)
syscall(643) !sock.gettx2data(maxinplen as word) as string
