'***********************************************************************************************************
'		GPRS LIBRARY
'		(Works with TELIT GC864 GPRS module)
'***********************************************************************************************************

include "global.tbh"

#if SUPPORTS_GPRS '##################################################

'--------------------------------------------------------------------
const GPRS_MAX_APN_LEN=24
const GPRS_STAMP="GPRS> "
const GPRS_CR_LF=chr(13)+chr(10)
const GPRS_REPLY_OK="OK"
const GPRS_REPLY_CONNECT="CONNECT"

const GPRS_PPP_BUFF_SIZE=GPRS_PAYLOAD_SIZE+1
const GPRS_SER_BUFF_SIZE=GPRS_PAYLOAD_SIZE*2+1
const GPRS_STD_TOUT=8
const GPRS_ECHO_TOUT=60
const GPRS_POST_RESET_TOUT=60
const GPRS_MAX_CMD_TRIES=5

const GPRS_PPP_ESC_CHAR=&h7D
const GPRS_PPP_ESC1=&h5E
const GPRS_PPP_REPL1=&h7E
const GPRS_PPP_ESC2=&h5D
const GPRS_PPP_REPL2=&h7D
const GPRS_PPP_XOR_MASK=&h20

const GPRS_GOOD_PPP_CS=&hF0B8

const GPRS_PPP_PROTO_LCP=&hC021
const GPRS_PPP_PROTO_PAP=&hC023
const GPRS_PPP_PROTO_IPCP=&h8021
const GPRS_PPP_PROTO_IP=&h0021

const GPRS_PPP_LCP_MESSAGE_02=2 'I have no idea what it is
const GPRS_PPP_LCP_MESSAGE_AUTH=3
const GPRS_PPP_LCP_MESSAGE_MAGIC=5
const GPRS_PPP_LCP_MESSAGE_PFC=7
const GPRS_PPP_LCP_MESSAGE_AFC=8

const GPRS_PPP_IPCP_MESSAGE_IP=3
const GPRS_PPP_IPCP_MESSAGE_DNS=129
const GPRS_PPP_IPCP_MESSAGE_DNS2=131

const GPRS_LCP_CONFREQ_STR=chr(&h02)+ chr(&h06)+ chr(&h0)+ chr(&h0)+ chr(&h0)+ chr(&h0)
const GPRS_LCP_OPTION_PFC_STR=chr(&h07)+ chr(&h02) 'used when constructing option reject
const GPRS_LCP_OPTION_AFC_STR=chr(&h08)+ chr(&h02) 'used when constructing option reject


const GPRS_PAP_CONFREQ_STR=chr(&h00)+ chr(&h00)
const GPRS_CCP_CONFREQ_STR=""

const GPRS_IPCP_CONFREQ_STR=chr(&h03)+ chr(&h06)+chr(&h00)+ chr(&h00)+ chr(&h00)+ chr(&h00)
const PING_STR="45 00 00 20 9a 00 00 00 20 01 00 00 00 00 00 00 00 00 00 00 08 00 30 39 02 00 01 00 61 62 63 64 "
'                                             -cs-- --our ip--- --ping ip-- 

const GPRS_INIT_SIGNATURE=&h125D
const GPRS_MAX_CMD_REPLY_LEN=128

'--------------------------------------------------------------------
enum gprs_ppp_codes
	GPRS_PPP_CONFREQ=1,
	GPRS_PPP_CONFACK,
	GPRS_PPP_CONFNAK,
	GPRS_PPP_CONFREJ,
	GPRS_PPP_ECHOREQ=9,
	GPRS_PPP_ID=12
end enum

enum gprs_phases
	GPRS_TOGGLE_POWER_1,
	GPRS_PAUSE_1,
	GPRS_PROBE_1,
	GPRS_TOGGLE_POWER_2,
	GPRS_PAUSE_2,
	GPRS_PROBE_2,
	GPRS_RESET_PULSE,
	GPRS_POST_RESET,
	GPRS_AT_AT,
	GPRS_AT_IPR,
	'GPRS_AT_ICF,
	GPRS_AT_IFC,
	GPRS_AT_CGDCONT,
	GPRS_AT_CGQMIN,
	GPRS_AT_DT,
	GPRS_PPP_LCP, 'this is where gprs_phase will be changed to GPRS_PH_PPP
	GPRS_PPP_PAP,
	GPRS_PPP_IPCP_1,
	GPRS_PPP_IPCP_2,
	GPRS_PPP_IPCP_3,
	GPRS_PPP_PING,
	GPRS_PPP_SESSION
end enum

enum gprs_lcp_parse_results
	GPRS_LCP_PARSE_RESULT_ACK,
	GPRS_LCP_PARSE_RESULT_NAK,
	GPRS_LCP_PARSE_RESULT_REJ,
	GPRS_LCP_PARSE_RESULT_DISCARD
end enum

'--------------------------------------------------------------------
declare sub gprs_next_phase()
declare sub gprs_proc_timer_2()
declare function gprs_parse_ping_reply() as ok_ng
declare function gprs_parse_ppp_message() as string
declare function gprs_parse_lcp_message(byref lcp_message as string, ppp_protocol as word, code as gprs_ppp_codes, byref rej_str as string) as gprs_lcp_parse_results
declare sub gprs_at_command(byref command as string, delay as byte)
declare sub gprs_ping_send()
declare sub gprs_ppp_send(ppp_protocol as word, ppp_code as gprs_ppp_codes, byref data as string, ser_num as byte, delay as byte)
declare function gprs_update_fcs(byref dt as string) as word
declare function gprs_fcs_value(x as byte) as word
declare sub gprs_insert_escape(byref command as string, pos as byte, replacement_char as byte)
declare sub gprs_start_over()
declare sub gprs_init()
declare sub gprs_eliminate_lf(byref s as string)
declare sub gprs_eliminate_double_cr(byref s as string)
declare sub gprs_debug_print_phase(gprs_phase as gprs_phases)
declare sub gprs_ppp_decode(byref log_string as string, byref full_command as string)
declare sub gprs_debugprint(byref print_data as string)
declare function gprs_print_hex(byref ss as string) as string

'--------------------------------------------------------------------
dim gprs_running as no_yes
dim gprs_linkup_in_prog as no_yes
dim gprs_phase as gprs_phases
dim gprs_tout_ctr as byte
dim gprs_cmd_try as byte
dim gprs_cmd as string(GPRS_MAX_CMD_REPLY_LEN)
dim gprs_reply as string(GPRS_MAX_CMD_REPLY_LEN)
dim gprs_rej as string(GPRS_MAX_CMD_REPLY_LEN)
dim gprs_ppp_peer_ip as string(4)
dim gprs_ppp_ip as string(4)
dim gprs_msg_ser_num_out as byte
dim gprs_our_request_confirmed,gprs_peer_request_confirmed as no_yes
dim gprs_at_dt_command as string(16)
dim gprs_init_flag as word
dim gprs_socket as byte
dim gprs_apn as string(GPRS_MAX_APN_LEN)
dim gprs_pap_required as no_yes
dim gprs_username as string(16)
dim gprs_password as string(16)

#if GPRS_DEBUG_PRINT
	dim gprs_dont_print_stop as no_yes
#endif

'====================================================================
public function gprs_get_info(info_element as gprs_info_elements, byref extra_data as string) as string
'API procedure, returns library-specific information according to the requested information element.

	gprs_get_info=""
	select case info_element
	case GPRS_INFO_ELEMENT_REQUIRED_BUFFERS:
		gprs_get_info=str(GPRS_PPP_BUFF_SIZE+GPRS_SER_BUFF_SIZE*2+2)
	
	end select
end function

'--------------------------------------------------------------------
public function gprs_start(byref at_dt_command_param as string, byref apn as string, byref username as string, byref password as string) as en_gprs_status_codes
'API procedure, starts the PPP login/configuration process.
	dim x as byte

	if gprs_init_flag<>GPRS_INIT_SIGNATURE then
		gprs_init()
		gprs_init_flag=GPRS_INIT_SIGNATURE
	end if

	gprs_at_dt_command="DT"+at_dt_command_param
	gprs_apn=apn
	gprs_username=username
	gprs_password=password

	gprs_start=GPRS_STATUS_OK

	'is this process already going?
	if gprs_running<>NO then
		#if GPRS_DEBUG_PRINT
			gprs_debugprint("GPRS already started")
		#endif
		exit function
	end if

	#if GPRS_DEBUG_PRINT
		gprs_debugprint("---START---")
	#endif

	'handle memory buffers -- calculate memory requirements
	x=val(gprs_get_info(GPRS_INFO_ELEMENT_REQUIRED_BUFFERS,""))
	if x>sys.freebuffpages then
		callback_gprs_pre_buffrq(x-sys.freebuffpages)
		
		if x>sys.freebuffpages then
			#if GPRS_DEBUG_PRINT
				gprs_debugprint("ERROR: insufficient buffer space")
			#endif
			gprs_start=GPRS_STATUS_INSUFFICIENT_BUFFER_SPACE
			goto gprs_start_error
		end if
	end if

	'prepare PPP object's buffers
	ser.num=GPRS_SER_PORT
	
	ser.enabled=NO
	ppp.portnum=GPRS_SER_PORT
	ppp.enabled=NO
	ppp.buffrq(GPRS_PPP_BUFF_SIZE)
	ser.rxbuffrq(GPRS_SER_BUFF_SIZE)
	ser.txbuffrq(GPRS_SER_BUFF_SIZE)
	sys.buffalloc
	
	ser.txclear
	ser.baudrate = ser.div9600/(38400/9600)
	ser.flowcontrol=ENABLED
	ser.rtsmap=GPRS_SER_PORT_RTSMAP
	ser.ctsmap=GPRS_SER_PORT_CTSMAP
	ser.enabled=YES
	io.num=ser.rtsmap
	io.enabled=YES

	
	'setup the socket for sending echo
	gprs_socket=sock_get("GPRS")
	sock.num=gprs_socket
	sock.rxbuffrq(1)
	sock.txbuffrq(1)
	sys.buffalloc
	sock.protocol=PL_SOCK_PROTOCOL_RAW
	sock.targetinterface=PL_SOCK_INTERFACE_PPP
	sock.allowedinterfaces="PPP"
	sock.inconmode=PL_SOCK_INCONMODE_NONE
	sock.reconmode=PL_SOCK_RECONMODE_3
	
	sock.targetbcast=YES
	sock.targetport=&hC021
	sock.outport=sock.targetport
	sock.localportlist=str(sock.targetport)


	#if GPRS_MODULE_EXTERNAL
		#if GPRS_DEBUG_PRINT
			gprs_debugprint("INFO: GPRS module is external, skipping 0-RESET and 1-POST RESET")
		#endif
		gprs_phase=GPRS_AT_AT
		gprs_tout_ctr=GPRS_STD_TOUT*8 'absolutely essential. Modem takes a log time to get ready.
		gprs_debugprint("INFO: DELAY to allow the modem to recover")
	#else
		'Switch to GPRS
		io.num=GPRS_SWITCH 
		io.enabled= YES
		io.state=LOW

		'start the "power toggling" of the GPRS module
		gprs_phase=GPRS_TOGGLE_POWER_1
		gprs_tout_ctr=GPRS_STD_TOUT
		io.num=GPRS_POWER
		io.state=HIGH
	#endif

	'reset variables
	gprs_cmd_try=0
	gprs_ppp_ip=chr(0)+chr(0)+chr(0)+chr(0)
	gprs_ppp_peer_ip=chr(0)+chr(0)+chr(0)+chr(0)
	gprs_msg_ser_num_out=0
	#if GPRS_DEBUG_PRINT
		gprs_debug_print_phase(gprs_phase)				
	#endif

	gprs_running=YES
	gprs_linkup_in_prog=YES
	gprs_pap_required=NO
	exit function
	
gprs_start_error:
	#if GPRS_DEBUG_PRINT
		gprs_debugprint("---FAILURE---")
	#endif
	
	#if GPRS_DEBUG_PRINT
		gprs_dont_print_stop=YES
	#endif
	
	gprs_stop()

	#if GPRS_DEBUG_PRINT
		gprs_dont_print_stop=NO
	#endif
end function

'--------------------------------------------------------------------
public sub gprs_stop()
'API procedure, stops (aborts) PPP link establishment or session.

	if gprs_init_flag<>GPRS_INIT_SIGNATURE then
		gprs_init()
		gprs_init_flag=GPRS_INIT_SIGNATURE
	end if

	#if GPRS_DEBUG_PRINT
		if gprs_dont_print_stop=NO then
			gprs_debugprint("---STOP---")
		end if
	#endif

	gprs_running=NO
	gprs_linkup_in_prog=NO

	ser.num=GPRS_SER_PORT

	'serial port can now be used for normal traffic again
	ppp.enabled=NO
	ser.enabled=NO

	sock_release(gprs_socket)


	'release buffer
	ppp.buffrq(0)
	ser.rxbuffrq(0)
	ser.txbuffrq(0)
	sys.buffalloc
end sub

'--------------------------------------------------------------------
public sub gprs_proc_sock_data()
'Event procedure, call it from the on_sock_data_arrival() event handler.	
	
	dim rx_data as string
		
	if gprs_init_flag<>GPRS_INIT_SIGNATURE or sock.num<>gprs_socket then
		exit sub
	end if

	rx_data=sock.getdata(255)
	select case asc(rx_data)
	case &h09:
		'echo request
		insert(rx_data,1,chr(&h0A)) 'replace "conf-req" with "conf-ack" and send it back
	
	case &h0A:
		'echo reply
		#if GPRS_DEBUG_PRINT
			gprs_debugprint("Echo reply")
		#endif
		gprs_cmd_try=0
	
	end select
end sub

'--------------------------------------------------------------------
public sub gprs_proc_ser_data()
'Event procedure, call it from the on_ser_data_arrival() event handler.	

	dim x as byte
	dim gprs_ppp_proto as word
	dim msg_ser_num_in as byte

	'is this GPRS port?
	if gprs_init_flag<>GPRS_INIT_SIGNATURE or ser.num<>GPRS_SER_PORT then
		exit sub
	end if

	'init not in progress? -- just clear out the buffer
	if gprs_linkup_in_prog=NO then
		gprs_reply=ser.getdata(255)
		exit sub
	end if
	
	ser.num=GPRS_SER_PORT
	if gprs_phase<GPRS_PPP_LCP then 
		'--- AT COMMANDS ---
		
		'general part for all AT replies
		gprs_reply=gprs_reply+ser.getdata(255)
	
		'correct reply will start with echoed command (but leftover garbage could be before it)
		gprs_eliminate_lf(gprs_reply)			'get rid of LFs
		gprs_eliminate_double_cr(gprs_reply)	'get rid of double CRs
		gprs_eliminate_lf(gprs_cmd)				'get rid of LFs
		gprs_eliminate_double_cr(gprs_cmd)		'get rid of double CRs
		
		x=instr(1,gprs_reply,gprs_cmd,1)
		if x=0 then
			'this is essential, was added later. We may have so much leftover TCP garbage that nothing new fits in
			if len(gprs_reply)=GPRS_MAX_CMD_REPLY_LEN then
				gprs_reply="" 
			end if
			
			'also added: modem may send info strings, which we must get rid of
			x=instr(1,gprs_reply,chr(13),1)
			while x>0
				gprs_reply=mid(gprs_reply,x+1,255)
				x=instr(1,gprs_reply,chr(13),1)
			wend
			exit sub
		end if
		
		'remove garbage before the echo
		gprs_reply=mid(gprs_reply,x,255)

		'a full reply will contain two CRs (we already got rid of LFs)
		if instr(1,gprs_reply,chr(13),2)=0 then
			exit sub 
		end if

		'remove echo and all CR/LFs
		gprs_reply=mid(gprs_reply,len(gprs_cmd)+1,len(gprs_reply)-len(gprs_cmd)-1)

		#if GPRS_DEBUG_PRINT
			gprs_debugprint("[AT__IN]: "+gprs_reply)
		#endif

		select case gprs_phase
		
		case GPRS_PROBE_1,GPRS_PROBE_2:
			'this is the reply to our AT command, so we now know that the module is ON
			gprs_phase=GPRS_POST_RESET
			gprs_tout_ctr=GPRS_POST_RESET_TOUT 'override standard reset in gprs_next_phase()	
			#if GPRS_DEBUG_PRINT
				gprs_debug_print_phase(gprs_phase)			
			#endif
		
		case GPRS_AT_AT:
			if gprs_reply=GPRS_REPLY_OK then
				gprs_next_phase()
			end if
		
		case GPRS_AT_IPR:
			if gprs_reply=GPRS_REPLY_OK then
				gprs_next_phase()
		end if
		
		'case GPRS_AT_ICF:
		'	if gprs_reply=GPRS_REPLY_OK then
		'		gprs_next_phase()
		'end if
		
		case GPRS_AT_IFC:
			if gprs_reply=GPRS_REPLY_OK then
				gprs_next_phase()
			end if
		
		case GPRS_AT_CGDCONT:
			if gprs_reply=GPRS_REPLY_OK then
				gprs_next_phase()
			end if
		
		case GPRS_AT_CGQMIN:
			if gprs_reply=GPRS_REPLY_OK then
				gprs_next_phase()
			end if
		
		case GPRS_AT_DT:
			if gprs_reply=GPRS_REPLY_CONNECT then
				gprs_next_phase()
			end if

		end select
		gprs_reply=""
	
	else
		'--- PPP EXCHANGE ---
		
		'wait for the whole PPP message to assemble
		gprs_reply=gprs_parse_ppp_message()
		if gprs_reply="" then
			exit sub
		end if

		#if GPRS_DEBUG_PRINT
			dim f as byte
			dim log_string as string
			dim s as string(2)
			log_string="[PPP___IN]:"
			for f=1 to len(gprs_reply)
				s=mid(hex(asc(mid(gprs_reply,f,1))),3,2)
				if len(s)=1 then s="0"+s
				log_string=log_string+s+" "
			next f
			log_string=log_string+" "
			for f=1 to len(gprs_reply)
				s=mid(gprs_reply,f,1)
				x=asc(s)
				if x<&h20 or x>&h7F then
					s="."
				end if
				log_string=log_string+s
			next f
			gprs_ppp_decode(log_string,gprs_reply)
			gprs_debugprint("RX "+log_string)
		#endif

		'verify length
		if asc(mid(gprs_reply,6,1))<>len(gprs_reply)-2 then
			exit sub
		end if

		'process PPP message
		gprs_ppp_proto=asc(left(gprs_reply,1))*256+asc(mid(gprs_reply,2,1))
		select case gprs_ppp_proto
		case GPRS_PPP_PROTO_LCP:
			'branch according to the LCP message type
			select case asc(mid(gprs_reply,3,1))
			case GPRS_PPP_CONFREQ:
				msg_ser_num_in=asc(mid(gprs_reply,4,1))
				gprs_reply=mid(gprs_reply,7,255) 'leave requested items only
			
			
			
			
				select case gprs_parse_lcp_message(gprs_reply,GPRS_PPP_PROTO_LCP,GPRS_PPP_CONFREQ,gprs_rej)
				case GPRS_LCP_PARSE_RESULT_ACK:
					if gprs_rej<>"" then
						'there are some options that need to be rejected
						gprs_ppp_send(GPRS_PPP_PROTO_LCP,GPRS_PPP_CONFREJ,gprs_rej,msg_ser_num_in,GPRS_STD_TOUT)
					else
						gprs_ppp_send(GPRS_PPP_PROTO_LCP,GPRS_PPP_CONFACK,gprs_reply,msg_ser_num_in,GPRS_STD_TOUT)
						gprs_peer_request_confirmed=YES
						if gprs_our_request_confirmed=YES and gprs_phase=GPRS_PPP_LCP then
							if gprs_pap_required=NO then gprs_phase=gprs_phase+1 'skip PAP
							gprs_next_phase()
						end if
					end if
					
				case GPRS_LCP_PARSE_RESULT_NAK, GPRS_LCP_PARSE_RESULT_REJ, GPRS_LCP_PARSE_RESULT_DISCARD:
					goto lcp_failed 'simplified handling -- we don't try to negotiate further
				
				end select

			case GPRS_PPP_CONFACK:
				'could only be acknowledging what we asked for
				gprs_our_request_confirmed=YES
				if gprs_peer_request_confirmed=YES and gprs_phase=GPRS_PPP_LCP then
					if gprs_pap_required=NO then gprs_phase=gprs_phase+1 'skip PAP
					gprs_next_phase()
				end if	

			case GPRS_PPP_CONFNAK, GPRS_PPP_CONFREJ:
				'could only be rejecting what we asked for
				goto lcp_failed

			end select
		
		case GPRS_PPP_PROTO_PAP:
			select case asc(mid(gprs_reply,3,1))
			case GPRS_PPP_CONFACK:
				if gprs_phase=GPRS_PPP_PAP then
					gprs_ppp_send(GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFREQ,GPRS_IPCP_CONFREQ_STR,gprs_msg_ser_num_out,GPRS_STD_TOUT) 
					gprs_next_phase()
				end if	

			case GPRS_PPP_CONFNAK:
				goto lcp_failed

			end select

		case GPRS_PPP_PROTO_IPCP:
			'branch according to the IPCP message type
			select case asc(mid(gprs_reply,3,1))
			case GPRS_PPP_CONFREQ:
				msg_ser_num_in=asc(mid(gprs_reply,4,1))
				gprs_reply=mid(gprs_reply,7,255) 'leave requested items only
				select case gprs_parse_lcp_message(gprs_reply,GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFREQ,gprs_rej)
				case GPRS_LCP_PARSE_RESULT_ACK:
					gprs_ppp_send(GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFACK,gprs_reply,msg_ser_num_in,GPRS_STD_TOUT)

					if gprs_phase=GPRS_PPP_IPCP_1 then
						gprs_next_phase()
					end if
					
				case GPRS_LCP_PARSE_RESULT_NAK, GPRS_LCP_PARSE_RESULT_REJ, GPRS_LCP_PARSE_RESULT_DISCARD:
					goto lcp_failed 'simplified handling -- we don't try to negotiate further
				
				end select

			case GPRS_PPP_CONFNAK:
				gprs_reply=mid(gprs_reply,7,255) 'leave requested items only
				gprs_parse_lcp_message(gprs_reply,GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFACK,gprs_rej)
				if gprs_phase=GPRS_PPP_IPCP_2 then
					gprs_next_phase()
				end if	

			case GPRS_PPP_CONFACK:
				gprs_reply=mid(gprs_reply,7,255) 'leave requested items only
				gprs_parse_lcp_message(gprs_reply,GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFACK,gprs_rej)
				if gprs_phase=GPRS_PPP_IPCP_3 then
					gprs_next_phase()
					#if GPRS_SEND_PING=0
						#if GPRS_DEBUG_PRINT
							gprs_debugprint("ping skipped")
						#endif
						gprs_next_phase()
					#endif
				
				end if	

			case GPRS_PPP_CONFREJ:
				'could only be rejecting what we asked for
lcp_failed:		#if GPRS_DEBUG_PRINT
					gprs_debugprint("---FAILURE---")
				#endif
				callback_gprs_failure()
				gprs_start_over()
				
			end select

		case GPRS_PPP_PROTO_IP:
			if gprs_parse_ping_reply()=OK then
				gprs_next_phase()
			end if
			
		end select
	end if
end sub

'--------------------------------------------------------------------
public sub gprs_proc_timer()
'Event procedure, call it from the on_sys_timer() event handler.	

	if gprs_init_flag<>GPRS_INIT_SIGNATURE or (gprs_linkup_in_prog=NO and gprs_phase<>GPRS_PPP_SESSION) then
		exit sub
	end if

	if gprs_phase=GPRS_TOGGLE_POWER_1 or gprs_phase=GPRS_PAUSE_1 or gprs_phase=GPRS_TOGGLE_POWER_2 or gprs_phase=GPRS_PAUSE_2 then
		if gprs_tout_ctr=0 then
				if gprs_phase=GPRS_TOGGLE_POWER_1 or gprs_phase=GPRS_TOGGLE_POWER_2 then
					#if GPRS_MODULE_EXTERNAL=0
						io.num=GPRS_POWER
						io.state=LOW
					#endif
					
					gprs_phase=gprs_phase+1
					gprs_tout_ctr=GPRS_STD_TOUT
					#if GPRS_DEBUG_PRINT
						gprs_debug_print_phase(gprs_phase)			
					#endif
				else
					ser.num=GPRS_SER_PORT
					gprs_phase=gprs_phase+1
					gprs_tout_ctr=GPRS_STD_TOUT
					#if GPRS_DEBUG_PRINT
						gprs_debug_print_phase(gprs_phase)			
					#endif
					gprs_at_command("",GPRS_STD_TOUT)
				end if
				
		else
			gprs_tout_ctr=gprs_tout_ctr-1
		end if
	else if gprs_phase=GPRS_RESET_PULSE or gprs_phase=GPRS_POST_RESET then
		if gprs_tout_ctr=0 then
				if gprs_phase=GPRS_RESET_PULSE then
					gprs_phase=gprs_phase+1
					gprs_tout_ctr=GPRS_POST_RESET_TOUT 'override standard reset in gprs_next_phase()	
					#if GPRS_DEBUG_PRINT
						gprs_debug_print_phase(gprs_phase)			
					#endif
				else
					gprs_phase=gprs_phase+1
					gprs_tout_ctr=1
					#if GPRS_DEBUG_PRINT
						gprs_debug_print_phase(gprs_phase)			
					#endif
				end if
				
		else
			gprs_tout_ctr=gprs_tout_ctr-1
		end if
	else
		gprs_proc_timer_2()
	end if
end sub

'--------------------------------------------------------------------
sub gprs_next_phase()
	gprs_phase=gprs_phase+1
	gprs_tout_ctr=0
	gprs_reply=""
	gprs_cmd_try=0
	gprs_our_request_confirmed=NO
	gprs_peer_request_confirmed=NO
		
	#if GPRS_DEBUG_PRINT
		gprs_debug_print_phase(gprs_phase)
	#endif

	gprs_proc_timer_2()
end sub

'--------------------------------------------------------------------
sub gprs_proc_timer_2()
	dim temp_str as string(16)

	if gprs_tout_ctr=0 then
		ser.num=GPRS_SER_PORT

		if gprs_cmd_try>=GPRS_MAX_CMD_TRIES then
			#if GPRS_DEBUG_PRINT
				gprs_debugprint("---LINK FAILED---")
			#endif
			callback_gprs_failure()
			gprs_start_over()
			exit sub
		end if

		if gprs_phase<GPRS_PPP_LCP then
			'--- AT COMMANDS ---
			
			select case gprs_phase
			case GPRS_PROBE_1:
				io.num=GPRS_POWER
				io.state=HIGH
				gprs_phase=gprs_phase+1
				gprs_tout_ctr=GPRS_STD_TOUT
			
			case GPRS_PROBE_2:
				#if GPRS_DEBUG_PRINT
					gprs_debugprint("---LINK FAILED---")
				#endif
				callback_gprs_failure()
				gprs_start_over()
			
			case GPRS_AT_AT:
				'send out "AT"
				gprs_at_command("",GPRS_STD_TOUT)
			
			case GPRS_AT_IPR:
				gprs_at_command("+IPR=38400",GPRS_STD_TOUT)
				
			'case GPRS_AT_ICF:
			'	gprs_at_command("+ICF=3",GPRS_STD_TOUT)
			
			case GPRS_AT_IFC:
				gprs_at_command("+IFC=2,2",GPRS_STD_TOUT)
			
			case GPRS_AT_CGDCONT:
				gprs_at_command("+CGDCONT=1,"+chr(`"`)+"IP"+chr(`"`)+","+chr(`"`)+gprs_apn+chr(`"`),GPRS_STD_TOUT)
			
			case GPRS_AT_CGQMIN:
				gprs_at_command("+CGQMIN=1,0,0,3,0,0",GPRS_STD_TOUT)
			
			case GPRS_AT_DT:
				gprs_at_command(gprs_at_dt_command,GPRS_STD_TOUT)

			end select
		
		else
			'--- PPP EXCHANGE ---
			
			select case gprs_phase		
			case GPRS_PPP_LCP:
				if gprs_our_request_confirmed=NO then
					gprs_ppp_send(GPRS_PPP_PROTO_LCP,GPRS_PPP_CONFREQ,GPRS_LCP_CONFREQ_STR,gprs_msg_ser_num_out,GPRS_STD_TOUT) 
				else
					gprs_tout_ctr=GPRS_STD_TOUT
					gprs_cmd_try=gprs_cmd_try+1
				end if

			case GPRS_PPP_PAP:
				temp_str=chr(len(gprs_username))+gprs_username+chr(len(gprs_password))+gprs_password
				gprs_ppp_send(GPRS_PPP_PROTO_PAP,GPRS_PPP_CONFREQ,temp_str,gprs_msg_ser_num_out,GPRS_STD_TOUT) 

			case GPRS_PPP_IPCP_1:
				gprs_tout_ctr=GPRS_STD_TOUT
				gprs_cmd_try=gprs_cmd_try+1
				gprs_ppp_send(GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFREQ,GPRS_IPCP_CONFREQ_STR,gprs_msg_ser_num_out,GPRS_STD_TOUT) 
			
			case GPRS_PPP_IPCP_2:
				gprs_ppp_send(GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFREQ,GPRS_IPCP_CONFREQ_STR,gprs_msg_ser_num_out,GPRS_STD_TOUT)

			case GPRS_PPP_IPCP_3:
				temp_str=GPRS_IPCP_CONFREQ_STR
				insert(temp_str,3,gprs_ppp_ip)
				gprs_ppp_send(GPRS_PPP_PROTO_IPCP,GPRS_PPP_CONFREQ,temp_str,gprs_msg_ser_num_out,GPRS_STD_TOUT)

			case GPRS_PPP_PING:
				#if GPRS_SEND_PING
					gprs_ping_send()
				#endif
				
			case GPRS_PPP_SESSION:
				if gprs_linkup_in_prog then
					gprs_linkup_in_prog=NO
					#if GPRS_DEBUG_PRINT
						gprs_debugprint("---LINKED---")
					#endif
					callback_gprs_ok()
					ppp.portnum=GPRS_SER_PORT
					ppp.ip=ddstr(gprs_ppp_ip)
					ppp.enabled=YES
				end if
				
				'send echo request
				#if GPRS_DEBUG_PRINT
					gprs_debugprint("Echo request")
				#endif
				
				sock.num=gprs_socket
				if sock.statesimple=PL_SSTS_CLOSED then
					sock.connect
				end if
				sock.setdata(chr(&h09)+chr(&h04)+chr(&h00)+chr(&h04)) 'echo request command
				sock.send

				gprs_tout_ctr=GPRS_ECHO_TOUT
				gprs_cmd_try=gprs_cmd_try+1

			end select
		end if
	else
		gprs_tout_ctr=gprs_tout_ctr-1
	end if
end sub

'--------------------------------------------------------------------
function gprs_parse_ping_reply() as ok_ng
	dim cs as dword
	dim w as word
	dim f as byte

	gprs_reply=mid(gprs_reply,3,255)
	cs=0
	for f=0 to 20/2-1
		w=asc(mid(gprs_reply,f*2+1,1))*256+asc(mid(gprs_reply,f*2+2,1))
		cs=cs+w
	next f
	
	if cs>65535 then
		cs=(cs and &hFFFF)+cs/65536
	end if

	if cs<>&hFFFF then
		gprs_parse_ping_reply=NG
		exit function
	end if

	if mid(gprs_reply,13,4)<>ddval(GPRS_PING_IP) then
		gprs_parse_ping_reply=NG
		exit function
	end if

	gprs_parse_ping_reply=OK
end function

'--------------------------------------------------------------------
function gprs_parse_ppp_message() as string
	dim rxlen as word
	dim f,x as byte
	
	rxlen=instr(1,ser.peekdata(255),chr(GPRS_PPP_REPL1),2)
	if rxlen=0 then
		gprs_parse_ppp_message=""
		exit function
	end if

	'we now have a PPP message encaplulated in GPRS_PPP_REPL1
	ser.getdata(1)	'get rid of the first GPRS_PPP_REPL1

	'remove escapes (restore packet)
	gprs_parse_ppp_message=""
	for f=1 to rxlen-2
		if asc(ser.peekdata(1))=GPRS_PPP_ESC_CHAR then
			'we have escape character next
			if ser.rxlen>2 then
				x=asc(ser.getdata(1)) 'we discard this
				f=f+1
				x=asc(ser.getdata(1))
				select case x
				case GPRS_PPP_ESC1:
					x=GPRS_PPP_REPL1
				case GPRS_PPP_ESC2:
					x=GPRS_PPP_REPL2
				case else:
					x=x xor GPRS_PPP_XOR_MASK
				end select
				gprs_parse_ppp_message=gprs_parse_ppp_message+chr(x)
			end if
		else
			'this is not an escape character
			gprs_parse_ppp_message=gprs_parse_ppp_message+ser.getdata(1)
		end if
	next f

	ser.getdata(1)	'get rid of the last GPRS_PPP_REPL1

	if gprs_update_fcs(gprs_parse_ppp_message)<>GPRS_GOOD_PPP_CS then
		gprs_parse_ppp_message=""
		exit function
	end if
	gprs_parse_ppp_message=left(gprs_parse_ppp_message,len(gprs_parse_ppp_message)-2)

	if asc(left(gprs_parse_ppp_message,1))<>&hFF or asc(mid(gprs_parse_ppp_message,2,1))<>&h03 then
		gprs_parse_ppp_message=""
		exit function
	end if
	gprs_parse_ppp_message=right(gprs_parse_ppp_message,len(gprs_parse_ppp_message)-2)
end function

'--------------------------------------------------------------------
function gprs_parse_lcp_message(byref lcp_message as string, ppp_protocol as word, code as gprs_ppp_codes, byref rej_str as string) as gprs_lcp_parse_results
	dim	option_length as byte
	dim lcp_message_copy as string(128)
	
	rej_str=""
	lcp_message_copy=lcp_message
	while lcp_message_copy<>""

		'check the length of the next option
		option_length=asc(mid(lcp_message_copy,2,1))
		if option_length>len(lcp_message_copy) then
			gprs_parse_lcp_message=GPRS_LCP_PARSE_RESULT_DISCARD
			exit function
		end if
		
		if ppp_protocol=GPRS_PPP_PROTO_LCP then
			select case asc(left(lcp_message_copy,1))
			case GPRS_PPP_LCP_MESSAGE_02:
				'---
			
			case GPRS_PPP_LCP_MESSAGE_AUTH:
				if asc(mid(lcp_message_copy,3,1))*256+asc(mid(lcp_message_copy,4,1))<>GPRS_PPP_PROTO_PAP then
					gprs_parse_lcp_message=GPRS_LCP_PARSE_RESULT_NAK
					exit function
				end if
				gprs_pap_required=YES
			
			case GPRS_PPP_LCP_MESSAGE_MAGIC:
				'---

			case GPRS_PPP_LCP_MESSAGE_PFC:
				rej_str=rej_str+GPRS_LCP_OPTION_PFC_STR
							
			case GPRS_PPP_LCP_MESSAGE_AFC:
				rej_str=rej_str+GPRS_LCP_OPTION_AFC_STR
			
			case else: 'unrecognized stuff
				gprs_parse_lcp_message=GPRS_LCP_PARSE_RESULT_REJ
				exit function
				
			end select
		else	'must be IPCP
			select case asc(left(lcp_message_copy,1))
			case GPRS_PPP_IPCP_MESSAGE_IP:
				if option_length<>6 then
					gprs_parse_lcp_message=GPRS_LCP_PARSE_RESULT_NAK
					exit function
				end if
				if code=GPRS_PPP_CONFREQ then
					gprs_ppp_peer_ip=right(lcp_message_copy,4)
				else
					gprs_ppp_ip=right(lcp_message_copy,4)
				end if
			
			case GPRS_PPP_IPCP_MESSAGE_DNS, GPRS_PPP_IPCP_MESSAGE_DNS2:
				'---
				
			case else: 'unrecognized stuff
				gprs_parse_lcp_message=GPRS_LCP_PARSE_RESULT_REJ
				exit function
				
			end select
		end if


		lcp_message_copy=mid(lcp_message_copy,option_length+1,255)
	wend
	gprs_parse_lcp_message=GPRS_LCP_PARSE_RESULT_ACK
end function

'--------------------------------------------------------------------
sub gprs_at_command(byref command as string, delay as byte)
	gprs_cmd="AT"+command
	
	#if GPRS_DEBUG_PRINT
		gprs_debugprint("[AT_OUT]: "+gprs_cmd)
	#endif
	
	gprs_cmd=gprs_cmd+GPRS_CR_LF
	
	ser.setdata(gprs_cmd) 
	ser.send
	gprs_tout_ctr=delay
	gprs_cmd_try=gprs_cmd_try+1
end sub

'--------------------------------------------------------------------
sub gprs_ping_send()
	dim f as byte
	dim w as word
	dim cs as dword
	
	gprs_cmd=""
	for f=0 to len(PING_STR)/3-1
		gprs_cmd=gprs_cmd+chr(val("&h"+mid(PING_STR,f*3+1,3)))
	next f

	insert(gprs_cmd,13,gprs_ppp_ip)
	insert(gprs_cmd,17,ddval(GPRS_PING_IP))

	cs=0
	for f=0 to 20/2-1
		w=asc(mid(gprs_cmd,f*2+1,1))*256+asc(mid(gprs_cmd,f*2+2,1))
		cs=cs+w
	next f
	if cs>65535 then
		cs=(cs and &hFFFF)+cs/65536
	end if
	cs=&hFFFF-cs
	
	insert(gprs_cmd,11,chr(cs/256))
	insert(gprs_cmd,12,chr(cs))

	gprs_ppp_send(GPRS_PPP_PROTO_IP,0,gprs_cmd,0,GPRS_STD_TOUT)	
end sub

'--------------------------------------------------------------------
sub gprs_ppp_send(ppp_protocol as word, ppp_code as gprs_ppp_codes, byref data as string, ser_num as byte, delay as byte)
	dim f,x as byte
	dim i as word
	dim full_command as string(128) 

	if ppp_protocol=GPRS_PPP_PROTO_IP then
		full_command=chr(ppp_protocol/256)+ chr(ppp_protocol)+data
	else
		full_command=chr(ppp_protocol/256)+ chr(ppp_protocol)+chr(ppp_code)+chr(ser_num)+chr(&h00)+chr(len(data)+4)+data
	end if
	
	#if GPRS_DEBUG_PRINT
		dim log_string as string
		dim s as string(2)

		log_string="[PPP_OUT]: "
		for f=1 to len(full_command)
			s=mid(hex(asc(mid(full_command,f,1))),3,2)
			if len(s)=1 then s="0"+s
			log_string=log_string+s+" "
		next f
		log_string=log_string+" "
		for f=1 to len(full_command)
			s=mid(full_command,f,1)
			x=asc(s)
			if x<&h20 or x>&h7F then
				s="."
			end if
			log_string=log_string+s
		next f
		gprs_ppp_decode(log_string,full_command)
		gprs_debugprint("TX "+log_string)
	#endif
	
	full_command=chr(&hFF)+chr(&h03)+full_command
	i=gprs_update_fcs(full_command)
	i=i xor &hFFFF
	full_command=full_command+chr(i)+chr(i/256)

	for f=1 to len(full_command)
		x=asc(mid(full_command,f,1))
		select case x
		case &h7E:
			gprs_insert_escape(full_command,f,&h5E)
			f=f+1
		case &h7D:
			gprs_insert_escape(full_command,f,&h5D)
			f=f+1
		case else:
			if x<&h20 then
				gprs_insert_escape(full_command,f,x xor &h20)
				f=f+1
			end if
		end select
	next f

	full_command=chr(&h7E)+full_command+chr(&h7E)
	ser.setdata(full_command)
	ser.send
	
	'we restart delay timer only if this is our command (REQ), not our reply
	if ppp_protocol=GPRS_PPP_PROTO_IP or ppp_code=GPRS_PPP_CONFREQ then
		gprs_tout_ctr=delay
		gprs_msg_ser_num_out=gprs_msg_ser_num_out+1
	end if
	
	gprs_cmd_try=gprs_cmd_try+1
end sub

'--------------------------------------------------------------------
function gprs_update_fcs(byref dt as string) as word
	dim f as byte

	gprs_update_fcs=&hFFFF
	for f=1 to len(dt)
		gprs_update_fcs=(gprs_update_fcs/256) xor gprs_fcs_value((gprs_update_fcs xor asc(mid(dt,f,1))) and &hFF)
	next f
end function

'--------------------------------------------------------------------
function gprs_fcs_value(x as byte) as word
	dim f as byte

	gprs_fcs_value=x
	for f=0 to 7
		if (gprs_fcs_value and 1)=1 then
			gprs_fcs_value=(gprs_fcs_value/2) xor &h8408
		else
			gprs_fcs_value=gprs_fcs_value/2
		end if
	next f
end function

'--------------------------------------------------------------------
sub gprs_insert_escape(byref command as string, pos as byte, replacement_char as byte)
	command=left(command,pos-1)+chr(&h7D)+chr(replacement_char)+right(command,len(command)-pos)
end sub

'--------------------------------------------------------------------
sub gprs_start_over()
	dim i as word
	dim s as string(10)

	ppp.enabled=NO
	gprs_linkup_in_prog=YES
	gprs_cmd_try=0

	#if GPRS_DEBUG_PRINT
		gprs_debugprint("---TRY AGAIN---")
	#endif

	#if GPRS_MODULE_EXTERNAL
		#if GPRS_DEBUG_PRINT
			gprs_debugprint("INFO: GPRS module is external, skipping 0-RESET and 1-POST RESET")
		#endif
		
		ser.flowcontrol=PL_SER_FC_DISABLED
		i=sys.timercount
		'this is a fixed delay of at least 1 second
		while sys.timercount-i<3
		wend
		'escape sequence
		ser.setdata("+++")
		ser.send
		'this is a fixed delay of at least 1 second
		while sys.timercount-i<3
		wend
		ser.rxclear	
		gprs_at_command("+CFUN=1,1",GPRS_STD_TOUT)
		'wait for OK (but limit the time we are waiting)
		i=sys.timercount
		while ser.rxlen=0 and sys.timercount-i<6
		wend
		while ser.rxlen>0
			s=ser.getdata(255)
		wend
		
		gprs_phase=GPRS_AT_AT
		gprs_tout_ctr=GPRS_STD_TOUT*8 'absolutely essential. Modem takes a log time to get ready.
		gprs_debugprint("INFO: DELAY to allow the modem to recover")
		
	#else
		'Switch to GPRS
		io.num=GPRS_SWITCH 
		io.enabled= YES
		io.state=LOW

		gprs_phase=GPRS_TOGGLE_POWER_1
		gprs_tout_ctr=GPRS_STD_TOUT
		io.num=GPRS_POWER
		io.state=HIGH

		#if GPRS_DEBUG_PRINT
			gprs_debug_print_phase(gprs_phase)				
		#endif
	#endif

end sub

'--------------------------------------------------------------------
sub gprs_init()
'Call this first to initialize this library to a safe idle state.

	ppp.enabled=NO
	gprs_running=NO
	gprs_linkup_in_prog=NO
	gprs_socket=sock_get("GPRS")
	gprs_apn=""
	gprs_username=""
	gprs_password=""
	
	#if GPRS_DEBUG_PRINT
		gprs_dont_print_stop=NO
	#endif
	
	'put the module in reset
	#if GPRS_MODULE_EXTERNAL=0
		io.num=GPRS_RESET
		io.state=LOW
		io.enabled=YES
		
		io.num=GPRS_POWER
		io.state=HIGH
		io.enabled=YES
	#endif
end sub

sub gprs_eliminate_lf(byref s as string)
		dim f as byte
		dim c as string(1)
		dim so as string(GPRS_MAX_CMD_REPLY_LEN)
		
		so=""
		for f=1 to len(s)
			c=mid(s,f,1)
			if c<>chr(10) then
				so=so+c
			end if
		next f
		s=so
end sub

sub gprs_eliminate_double_cr(byref s as string)
		dim f as byte
		dim c as string(1)
		dim so as string(GPRS_MAX_CMD_REPLY_LEN)
		dim cr_encountered as no_yes=NO
		
		so=""
		for f=1 to len(s)
			c=mid(s,f,1)
			if c<>chr(13) or cr_encountered=NO then
				so=so+c
			end if
		
			if c=chr(13) then
				cr_encountered=YES
			else	
				cr_encountered=NO
			end if
		next f
		s=so
end sub

'--------------------------------------------------------------------
#if GPRS_DEBUG_PRINT
sub gprs_debug_print_phase(phase as gprs_phases)
	dim s as string(64)

	select case phase
	case GPRS_TOGGLE_POWER_1: s="TOGGLE POWER (1)"
	case GPRS_PAUSE_1: s="PAUSE (1)"
	case GPRS_PROBE_1: s="PROBE (1)"
	case GPRS_TOGGLE_POWER_2: s="TOGGLE POWER (2)"
	case GPRS_PAUSE_2: s="PAUSE (2)"
	case GPRS_PROBE_2: s="PROBE (2)"
	case GPRS_RESET_PULSE: s="RESET"
	case GPRS_POST_RESET: s="POST RESET (wait for GPRS to 'recover')"
	case GPRS_AT_AT: s="AT"
	case GPRS_AT_IPR: s="IPR"
	'case GPRS_AT_ICF: s="ICF"
	case GPRS_AT_IFC: s="Q3"
	case GPRS_AT_CGDCONT: s="CGDCONT"
	case GPRS_AT_CGQMIN: s="CGQMIN"
	case GPRS_AT_DT: s="DT"
	case GPRS_PPP_LCP: s="LCP(main)"
	case GPRS_PPP_PAP: s="PAP"
	case GPRS_PPP_IPCP_1: s="IPCP_1 (wait REQ)"
	case GPRS_PPP_IPCP_2: s="IPCP_2 (send REQ and expect NAK)"
	case GPRS_PPP_IPCP_3: s="IPCP_3 (send REQ and expect ACK)"
	case GPRS_PPP_PING: s="PING"
	case GPRS_PPP_SESSION: s="SESSION (linked up)"
	end select
	gprs_debugprint("PHASE: "+str(phase)+"-"+s)
end sub
#endif

#if GPRS_DEBUG_PRINT
sub gprs_ppp_decode(byref log_string as string, byref full_command as string)
	dim proto,i as word
	dim pos,f,code,otype, olen as byte
	dim flen as word
	dim s as string(3)
	
	log_string=""
	
	proto=asc(mid(full_command,1,1))*256+asc(mid(full_command,2,1))
	select case proto
	case &hC021:
		log_string=log_string+" LCP/"
	
	case &hC023:
		log_string=log_string+" PAP/"
	
	case &h8021:
		log_string=log_string+" IPCP/"
	
	case &h0021:
		log_string=log_string+"ARP"
	
	case else:
		log_string=log_string+" proto_"+mid(hex(proto),3,255)+"/"
		
	end select

	pos=3
	
	select case proto
	
	case &hC021: '----- LCP -----
		while pos<=len(full_command)
			code=asc(mid(full_command,pos,1))
			select case code
			case 1:    log_string=log_string+"CONF-REQ"
			case 2:    log_string=log_string+"CONF-ACK"
			case 3:    log_string=log_string+"CONF-NAK"
			case 4:    log_string=log_string+"CONF-REJ"
			case 5:    log_string=log_string+"TERM-REQ"
			case 6:    log_string=log_string+"TERM-ACK"
			case 7:    log_string=log_string+"CODE-REJ"
			case 8:    log_string=log_string+"PROT-REJ"
			case 9:    log_string=log_string+"ECHO-REQ"
			case 10:   log_string=log_string+"ECHO-RPL"
			case 11:   log_string=log_string+"DISC-REQ"
			case else: log_string=log_string+"code_"+str(code)
			end select
			
			pos=pos+1
			log_string=log_string+" #"+str(asc(mid(full_command,pos,1)))
			
			pos=pos+1
			flen=asc(mid(full_command,pos,1))*256+asc(mid(full_command,pos+1,1))
					
			pos=pos+2
			if flen>4 then
				flen=flen-4
				log_string=log_string+" "+str(flen)+": ["
				f=1
				while f<flen
					log_string=log_string+"("
					otype=asc(mid(full_command,pos,1))
					select case otype
					case 0:    log_string=log_string+"rsrvd"
					case 1:    log_string=log_string+"m-r-u"	'maximum-receive-unit
					case 2:	   log_string=log_string+"a-ccm"	'async-control-character-map
					case 3:    log_string=log_string+"au-pr"	'authentication-type (protocol)
					case 4:    log_string=log_string+"qu-pr"	'quality-protocol
					case 5:    log_string=log_string+"magic"	'magic-number
					case 6:    log_string=log_string+"l-q-m"	'link-quality-monitoring
					case 7:    log_string=log_string+"p-f-c"	'protocol-field-compression
					case 8:    log_string=log_string+"a-f-c"	'address-and-control-field-compression
					case 9:    log_string=log_string+"fcs-a"	'FCS-alternatives
					case 10:   log_string=log_string+"s-d-p"	'self-describing-padding 
					case 13:   log_string=log_string+"cback"	'callback
					case 15:   log_string=log_string+"c-fra"	'compaund-frames
					
					case else: log_string=log_string+"option_"+str(otype)
					end select
					
					pos=pos+1
					f=f+1
					olen=asc(mid(full_command,pos,1))
					
					pos=pos+1
					f=f+1
					if olen>=2 then
						olen=olen-2
						if olen>0 then
							log_string=log_string+" "+str(olen)+": "
						end if

						select case otype
						case 0: 
						
						case 1: 
							log_string=log_string+str(asc(mid(full_command,pos,1))*256+asc(mid(full_command,pos+1,1)))
						
						case 2:
							log_string=log_string+gprs_print_hex(mid(full_command,pos,1))+","+gprs_print_hex(mid(full_command,pos+1,1))+","+gprs_print_hex(mid(full_command,pos+2,1))+","+gprs_print_hex(mid(full_command,pos+3,1))
						
						case 3: 
							i=hex(asc(mid(full_command,pos,1))*256+asc(mid(full_command,pos+1,1)))
							if i=GPRS_PPP_PROTO_PAP then
								log_string=log_string+"PAP"
							else
								log_string=log_string+mid(hex(i),3,255)+"(?)"
							end if
												
						case 4:
						
						case 5:	
							log_string=log_string+gprs_print_hex(mid(full_command,pos,1))+"-"+gprs_print_hex(mid(full_command,pos+1,1))+"-"+gprs_print_hex(mid(full_command,pos+2,1))+"-"+gprs_print_hex(mid(full_command,pos+3,1))
						
						case 7:
						
						case 8:
						
						case 9:
						
						case 10:
						
						case 13:
						
						case 15:
						
						case else:
						
						end select
						
						pos=pos+olen
						f=f+olen
					else	
						log_string=log_string+" error!"
					end if
					
					log_string=log_string+")"
				wend
				log_string=log_string+"]"
				
			else
				log_string=log_string+" error!"
			end if
		wend

	
	case &hC023: '------ PAP -----
		code=asc(mid(full_command,pos,1))
		select case code
		case 1:    log_string=log_string+"AUTH-REQ"
		case 2:    log_string=log_string+"AUTH-ACK"
		case 3:    log_string=log_string+"AUTH-NAK"
		case else: log_string=log_string+"code_"+str(code)
		end select
		
		pos=pos+1
		log_string=log_string+" #"+str(asc(mid(full_command,pos,1)))
		
		pos=pos+1
		flen=asc(mid(full_command,pos,1))*256+asc(mid(full_command,pos+1,1))
				
		pos=pos+2

		select case code
		case 1:
			if flen>4 then
				flen=flen-4
				log_string=log_string+" "+str(flen)+": ["
				f=1
				while f<=flen
					log_string=log_string+"("
					olen=asc(mid(full_command,pos,1))
					pos=pos+1
					f=f+1
					if olen>=1 then
						olen=olen-1
						if olen>0 then
							log_string=log_string+" "+str(olen)+": "
						
						end if
					end if
					
					log_string=log_string+")"
				wend
				log_string=log_string+"]"
				
			else
				log_string=log_string+" error!"
			end if

		case 2,3:
			if flen>1 then
				flen=flen-1
				log_string=log_string+" "+str(flen)+": ["
				olen=asc(mid(full_command,pos,1))
				pos=pos+1
				f=f+1
				if olen>=1 then
					log_string=log_string+" "+str(olen)+": "
					log_string=log_string+mid(full_command,pos,olen)
				end if
				log_string=log_string+"]"
			else
				log_string=log_string+" error!"
			end if

		case else:
		end select


	case &h8021: '----- IPCP -----
		while pos<=len(full_command)
			code=asc(mid(full_command,pos,1))
			select case code
			case 1:    log_string=log_string+"CONF-REQ"
			case 2:    log_string=log_string+"CONF-ACK"
			case 3:    log_string=log_string+"CONF-NAK"
			case 4:    log_string=log_string+"CONF-REJ"
			case 5:    log_string=log_string+"TERM-REQ"
			case 6:    log_string=log_string+"TERM-ACK"
			case 7:    log_string=log_string+"CODE-REJ"
			case 8:    log_string=log_string+"PROT-REJ"
			case 9:    log_string=log_string+"ECHO-REQ"
			case 10:   log_string=log_string+"ECHO-RPL"
			case 11:   log_string=log_string+"DISC-REQ"
			case else: log_string=log_string+"code_"+str(code)
			end select
			
			pos=pos+1
			log_string=log_string+" #"+str(asc(mid(full_command,pos,1)))
			
			pos=pos+1
			flen=asc(mid(full_command,pos,1))*256+asc(mid(full_command,pos+1,1))
					
			pos=pos+2
			if flen>4 then
				flen=flen-4
				log_string=log_string+" "+str(flen)+": ["
				f=1
				while f<flen
					log_string=log_string+"("
					otype=asc(mid(full_command,pos,1))
					select case otype
					case 1:    log_string=log_string+"ip-ss"	'ip-addresses (obsolete)
					case 2:	   log_string=log_string+"i-c-p"	'ip-compression-protocol
					case 3:    log_string=log_string+"ip-ad"	'ip-address
					case else: log_string=log_string+"option_"+str(otype)
					end select
					
					pos=pos+1
					f=f+1
					olen=asc(mid(full_command,pos,1))
					
					pos=pos+1
					f=f+1
					if olen>=2 then
						olen=olen-2
						if olen>0 then
							log_string=log_string+" "+str(olen)+": "
						end if

						select case otype
						case 2:
							log_string=log_string+gprs_print_hex(mid(full_command,pos,1))+" "+gprs_print_hex(mid(full_command,pos+1,1))
							
						case 3: 
							log_string=log_string+str(asc(mid(full_command,pos,1)))+"."+str(asc(mid(full_command,pos+1,1)))+"."+str(asc(mid(full_command,pos+2,1)))+"."+str(asc(mid(full_command,pos+3,1)))
												
						case 4:
						
						case 5:	
						
						case 7:
						
						case 8:
						
						case 9:
						
						case 10:
						
						case 13:
						
						case 15:
						
						case else:
						
						end select
						
						pos=pos+olen
						f=f+olen
					else	
						log_string=log_string+" error!"
					end if
					
					log_string=log_string+")"
				wend
				log_string=log_string+"]"
				
			else
				log_string=log_string+" error!"
			end if
		wend
	
	case else:

	end select

end sub
#endif

'------------------------------------------------------------------------------
#if GPRS_DEBUG_PRINT
function gprs_print_hex(byref ss as string) as string
	dim s as string
	dim f as byte
	
	gprs_print_hex=""
	for f=1 to len(ss)
		s=mid(hex(asc(mid(ss,f,1))),3,2)
		if len(s)=1 then s="0"+s
		gprs_print_hex=gprs_print_hex+s
	next f
end function
#endif

'------------------------------------------------------------------------------
#if GPRS_DEBUG_PRINT
sub gprs_debugprint(byref print_data as string)

	sys.debugprint(GPRS_STAMP+print_data+GPRS_CR_LF)
end sub
#endif

#endif '##################################################