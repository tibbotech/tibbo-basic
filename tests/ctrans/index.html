<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>

<body>
	<div id="root"></div>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
		integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous" />
	<link href="https://cdnjs.cloudflare.com/ajax/libs/react-grid-layout/1.3.4/css/styles.min.css" />
	<script src="https://unpkg.com/react/umd/react.production.min.js"></script>
	<script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
		integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
		crossorigin="anonymous"></script>
	<script src='https://unpkg.com/react-router-dom@5.0.0/umd/react-router-dom.min.js'></script>
	<script src="https://unpkg.com/react-bootstrap@next/dist/react-bootstrap.min.js" crossorigin></script>
	<script src="https://unpkg.com/prop-types/prop-types.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/react-grid-layout/0.16.6/react-grid-layout.min.js"></script>
	<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
	<script src="https://unpkg.com/recharts@1.6.2/umd/Recharts.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/react-chartjs-2/2.9.0/react-chartjs-2.min.js"></script>

	<script src="https://unpkg.com/@mui/material@latest/umd/material-ui.development.js"
		crossorigin="anonymous"></script>
	<script data-plugins="transform-modules-umd" data-presets="react" type="text/babel" src="/Widgets.js"></script>
	<script data-plugins="transform-modules-umd" data-presets="react" type="text/babel" src="/Information.js"></script>
	<script data-plugins="transform-modules-umd" data-presets="react" type="text/babel" src="/Database.js"></script>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
	<link rel="stylesheet"
		href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,1,0" />
	<!-- Icons to support Material Design -->
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />


	<script type="text/babel">
		const {
			Container: MuiContainer,
			Stack,
			TextField,
			Button: MuiButton,
			Switch,
			Snackbar,
			Slider,
		} = MaterialUI;

		const {
			SliderWidget,
			BarWidget,
			CmdButtonWidget,
			GaugeWidget,
			SwitchWidget,
			CardWidget,
			TextInputWidget,
			LineWidget,
		} = Widgets;

		const {
			Information
		} = Information;
		const {
			Log,
			Database,
		} = Database;

		const {
			Line
		} = ReactChartjs2

		const ResponsiveReactGridLayout = ReactGridLayout.WidthProvider(ReactGridLayout.Responsive);
		const Link = ReactRouterDOM.Link;
		const NavLink = ReactRouterDOM.NavLink;
		const Route = ReactRouterDOM.Route;
		const Container = window.ReactBootstrap.Container;
		const Modal = window.ReactBootstrap.Modal;
		const Row = window.ReactBootstrap.Row;
		const Col = window.ReactBootstrap.Col;
		const ListGroup = window.ReactBootstrap.ListGroup;
		const Form = window.ReactBootstrap.Form;
		const Button = window.ReactBootstrap.Button;
		const ProgressBar = window.ReactBootstrap.ProgressBar;
		const Table = window.ReactBootstrap.Table;
		const ButtonGroup = window.ReactBootstrap.ButtonGroup;
		const Pagination = window.ReactBootstrap.Pagination;
		const Spinner = window.ReactBootstrap.Spinner;
		const Tabs = window.ReactBootstrap.Tabs;
		const Tab = window.ReactBootstrap.Tab;
		let DASHBOARD_STATE = {};
		DASHBOARD_STATE.firmwareUpgrade = true;
		DASHBOARD_STATE.tablesEnabled = true;
		DASHBOARD_STATE.widgetsEnabled = true;
		DASHBOARD_STATE.title = "Tibbo Device Dashboard";

		
DASHBOARD_STATE.firmwareUpgrade = true;

DASHBOARD_STATE.title = "Tibbo Device Dashboard";

DASHBOARD_STATE.tablesEnabled = true;


		let sessionToken = '';

		const ROWS_PER_PAGE = 10;
		const API_URL_BASE = window.location.hostname == 'localhost' ? 'http://192.168.1.110' : '';
		const CONNECTION_TYPE_BLE = 'BLE';
		const CONNECTION_TYPE_HTTP = 'HTTP';

		var widgets = [];
		var updateInterval = 1000;
		var currentConnectionType = CONNECTION_TYPE_HTTP;
		
		widgets = [{ "x": 0, "y": 0, "w": 5, "h": 2, "variable": "la0r0ujth5thngzbma", "i": "1667458516646", "type": "line", "id": "1667458516646", "settings": { "label": "light", "bounds": true, "values": 50, "min": 0, "max": "60" }, "linkType": "variable", "value": "0", "error": false }]
		
updateInterval = 1 * 1000;
widgets = [];

		let UNOWIRE_SENSORS = [];
		

		function fetchAPI(urlParams, config) {
			return fetch(`${API_URL_BASE}/api.html?${urlParams}`, config);
		}



		class App extends React.Component {
			constructor(props) {
				super(props);
				this.state = {
					showNav: false,
					isPageVisible: true,
				};
				this.onVisibilityChange = this.onVisibilityChange.bind(this);
			}

			componentDidMount() {
				window.addEventListener('visibilitychange', this.onVisibilityChange)
			}

			componentWillUnmount() {
				window.removeEventListener('visibilitychange', this.onVisibilityChange)
			}


			onVisibilityChange() {
				if (document.visibilityState === 'visible') {
					this.setState({
						isPageVisible: true,
					})
				} else {
					this.setState({
						isPageVisible: false,
					})
				}
			}

			render() {
				return (
					<ReactRouterDOM.HashRouter>
						<header className="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0 shadow">
							<a className="navbar-brand col-md-3 col-lg-2 me-0 px-3 fs-6" href="#">{DASHBOARD_STATE.title}</a>
							<button className="navbar-toggler position-absolute d-md-none collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#sidebarMenu" aria-controls="sidebarMenu" aria-expanded="false" aria-label="Toggle navigation">
								<span className="navbar-toggler-icon"></span>
							</button>
							<div className="navbar-nav">
							</div>
						</header>

						<div className="container-fluid">
							<div className="row">
								<nav id="sidebarMenu" className={`col-md-3 col-lg-2 d-md-block bg-light sidebar ${this.state.showNav ? 'show' : 'collapse'}`}>
									<div className="position-sticky pt-3">
										<ul className="nav flex-column">
											<li className="nav-item">
												<NavLink to="/" className="nav-link" exact activeClassName="active">Home</NavLink>
											</li>
											{DASHBOARD_STATE.widgetsEnabled && (
												<li className="nav-item">
													<NavLink to="/dashboard" className="nav-link" exact activeClassName="active">Dashboard</NavLink>
												</li>
											)}
											{DASHBOARD_STATE.settingsEnabled && (
												<li className="nav-item">
													<NavLink to="/settings" className="nav-link" exact activeClassName="active">Settings</NavLink>
												</li>
											)}
											{DASHBOARD_STATE.tablesEnabled && (
												<li className="nav-item">
													<NavLink
														to="/database" className="nav-link" exact activeClassName="active">Database</NavLink>
												</li>
											)}
											{DASHBOARD_STATE.tablesEnabled && (
												<li className="nav-item">
													<NavLink
														to="/log" className="nav-link" exact activeClassName="active">Log</NavLink>
												</li>
											)}
											{DASHBOARD_STATE.unowiresEnabled && (
												<li className="nav-item">
													<NavLink
														to="/unowiresensors" className="nav-link" exact activeClassName="active">1-Wire Sensors</NavLink>
												</li>
											)}
											{DASHBOARD_STATE.firmwareUpgrade && (
												<li className="nav-item">
													<NavLink
														to="/firmware" className="nav-link" exact activeClassName="active">Firmware</NavLink>
												</li>
											)}
										</ul>
									</div>
								</nav>

								<main className="col-md-9 ms-sm-auto col-lg-10 px-md-4">
									<div className="container-fluid" style={{
										paddingTop: 16
									}}>
										<Route path="/" exact component={() => <Home isPageVisible={this.state.isPageVisible} />} />
										<Route path="/dashboard" component={() => <Dashboard isPageVisible={this.state.isPageVisible} />} />
										<Route path="/settings" component={Settings} />
										<Route path="/database" component={DatabaseWrapper} />
										<Route path="/log" component={LogWrapper} />
										<Route path="/unowiresensors" component={UnoWireSensors} />
										<Route path="/firmware" component={Firmware} />
									</div>
									<footer style={{
										position: 'fixed',
										bottom: 0,
										padding: 10
									}}>
										<Col>© {new Date().getFullYear()} Tibbo Technology Inc.</Col>
										<Col id="actions">

										</Col>
									</footer>
								</main>
							</div>
						</div>
					</ReactRouterDOM.HashRouter>
				)
			}
		}

		class Home extends React.Component {
			constructor(props) {
				super(props);

				this.state = {
					isMounting: true,
					infos: []
				}

				this.update = this.update.bind(this);
			}


			componentWillUnmount() {
				if (this.timer) {
					clearInterval(this.timer);
				}
			}

			componentDidMount() {
				this.timer = setInterval(() => {
					if (!this.props.isPageVisible) return
					if (!this.state.isMounting) return
					fetch(`${API_URL_BASE}/api.html?e=i&action=get`)
						.then(res => res.text())
						.then(res => {
							this.setState({
								isMounting: false,
								infos: JSON.parse(res.replace(/'/g, '"'))
							})
						})
				}
					, updateInterval)
			}

			update() {
				fetch(`${API_URL_BASE}/api.html?e=i&action=get`)
					.then(res=> res.text())
					.then(res => {
						this.setState({
							isMounting: false,
							infos:JSON.parse(res.replace(/'/g,'"'))
						})
					}) 
			}

			render() {
				return (
					<div>
						<h2>Home</h2>
						{this.state.isMounting ?
							<div>Loading...</div>
						:
						<Information infoValues={this.state.infos} update={this.update} />
						}
					</div>
				)
			}
		}

		class Dashboard extends React.Component {
			constructor(props) {
				super(props);
				for (let i = 0; i < widgets.length; i++) {
					widgets[i].data = [];
					widgets[i].static = true;
				}
				this.state = {
					widgets: widgets,
					commands: [],
					snackbarOn: false,
					isRequesting: false,
					loadingVariables: {},
				}
				this.setWidgetValue = this.setWidgetValue.bind(this);
				this.setSettingValue = this.setSettingValue.bind(this);
				this.sendValue = this.sendValue.bind(this);
				this.setSnackbarOn = this.setSnackbarOn.bind(this);
			}

			componentWillUnmount() {
				if (this.timer) {
					clearInterval(this.timer);
				}
			}

			executeWidgetAction(widget, options) {
				switch (widget.linkType) {
					case 'command':
						const requestOptions = {
							method: 'POST',
							body: `e=f&cmd=${widget.variable}&value=${options.value}`,
						};
						fetch(`${API_URL_BASE}/api.html`, requestOptions)
							.then(res => res.text())
							.then(
								(result) => {
									alert('sent');
								},
								(error) => {
									alert('error sending', error);
									console.error(error);
								}
							);
						break;
				}
			}

			componentDidMount() {
				this.timer = setInterval(() => {
					if (!this.props.isPageVisible) return
					let variablesToFetch = [];
					let commandsToFetch = [];
					const newWidgets = this.state.widgets;
					for (let i = 0; i < newWidgets.length; i++) {
						const widget = this.state.widgets[i];
						if (currentConnectionType === CONNECTION_TYPE_BLE) {
							const command = `G${widget.variable}`;
							this.sendCommand(command);
							continue
						}
						switch (widget.linkType) {
							case 'variable':
								variablesToFetch.push(widget.variable);
								break;
							case 'command':
								break;
							default:
								break;
						}
					}
					variablesToFetch = [...new Set(variablesToFetch)]
					for (let i = 0; i < variablesToFetch.length; i++) {
						const currentVariable = variablesToFetch[i]

						if (Object.prototype.hasOwnProperty
							.call(this.state.loadingVariables, currentVariable)) return
						var newLoadingVariables = this.state.loadingVariables
						newLoadingVariables[currentVariable] = currentVariable
						this.setState({
							loadingVariables: newLoadingVariables
						})
						fetch(`${API_URL_BASE}/api.html?e=v&variable=${variablesToFetch[i]}&action=get`)
							.then(res => res.text())
							.then(
								(result) => {
									for (let j = 0; j < newWidgets.length; j++) {
										if (newWidgets[j].variable === currentVariable) {
											newWidgets[j].value = result.trim();
											newWidgets[j].data.push({
												name: new Date().toLocaleTimeString(),
												value: newWidgets[j].value
											});

										}
									}
									delete newLoadingVariables[currentVariable]
									this.setState({
										widgets: newWidgets,
										loadingVariables: newLoadingVariables
									});
								},
								// Note: it's important to handle errors here
								// instead of a catch() block so that we don't swallow
								// exceptions from actual bugs in components.
								(error) => {
									console.error(error);
								}
							);
					}
					this.setState({
						isLoading: false,
					})
				}, updateInterval);
			}


			setWidgetValue(value, widget, name) {
				const { widgets } = this.state;
				for (let i = 0; i < widgets.length; i++) {
					if (widgets[i].id === widget.id) {
						widgets[i][name] = value;
						break;
					}
				}
				this.setState({
					widgets,
				});
			}

			setSettingValue(value, widget, settingName) {
				const { widgets } = this.state;
				for (let i = 0; i < widgets.length; i++) {
					if (widgets[i].id === widget.id) {
						widgets[i]['settings'][settingName] = value;
						break;
					}
				}
				this.setState({
					widgets,
				});
			}

			sendValue(event, widget) {
				if (this.state.isRequesting) {
					return
				}
				if (event) {
					event.preventDefault();
				}
				let actionType = 'v'; // set variable
				if (widget.linkType === 'command') {
					actionType = 'f'; // send command
				}
				const requestOptions = {
					method: 'POST',
					body: `e=${actionType}&action=set&variable=${widget.variable}&value=${widget.tmpValue}`,
				};
				this.setState({
					isRequesting: true,
				})
				return fetch(`${API_URL_BASE}/api.html`, requestOptions)
					.then(response => response.text())
					.then(data => {
						// alert('sent');
						this.setSnackbarOn(true);
						this.setState({
							isRequesting: false,
						})
					});
			}

			setSnackbarOn(value) {
				const { snackbarOn } = this.state;
				const newSnackbarOn = value;
				this.setState({
					snackbarOn: newSnackbarOn
				});
			}

			handleCloseSnackBar() {
				this.setSnackbarOn(false)
			}

			renderWidget(widget) {
				let element;
				switch (widget.type) {
					case 'line':
						const data = [...widget.data];
						for (let i = 0; i < data.length; i++) {
							data[i].value = Number(data[i].value);
						}
						element = (
							// <Recharts.ResponsiveContainer height="100%" width="100%">
							// 	<Recharts.LineChart data={data}>
							// 		<Recharts.Line type="monotone" dataKey="value" stroke="#8884d8" />
							// 		<Recharts.CartesianGrid stroke="#ccc" />
							// 		<Recharts.XAxis dataKey="name" />
							// 		<Recharts.YAxis />
							// 	</Recharts.LineChart>
							// </Recharts.ResponsiveContainer>
							<LineWidget widget={widget} />
						);
						break;
					case 'text':
						element = (
							<TextInputWidget
								widget={widget}
								isRequesting={this.state.isRequesting}
								setWidgetValue={this.setWidgetValue}
								sendValue={this.sendValue} />

						);
						break;
					case 'switch':
						element = (
							<SwitchWidget
								widget={widget}
								isRequesting={this.state.isRequesting}
								setSettingValue={this.setSettingValue}
								setWidgetValue={this.setWidgetValue}
								sendValue={this.sendValue}
							/>
						);
						break;
					case 'card':
						element = (
							<CardWidget widget={widget} />
						);
						break;
					case 'bar':
						element = (
							<BarWidget widget={widget} />
						);
						break;

					case 'gauge':
						element = (
							<GaugeWidget widget={widget} />
						);
						break;
					case 'slider':
						element = (
							<SliderWidget widget={widget} setWidgetValue={this.setWidgetValue} sendValue={this.sendValue} isRequesting={this.state.isRequesting} />
						);
						break;
					case 'button':
						element = (
							<CmdButtonWidget widget={widget} setWidgetValue={this.setWidgetValue} sendValue={this.sendValue} isRequesting={this.state.isRequesting} />
						);
						break;
					default:
						element = (
							<div>
								<h2>Value: {widget.value}</h2>
							</div>
						);
						break;
				}
				return (
					<div key={widget.id} className="grid-item"
						style={{
							boxShadow: "7px 5px 10px -8px rgba(0,0,0,0.75)",
							padding: '0.5rem 0',
							border: '1px solid #aaa'
						}}>
						{element}
					</div>
				)
			}

			render() {
				return (
					<div>
						<h2>Dashboard</h2>
						<ResponsiveReactGridLayout
							layouts={{ lg: this.state.widgets }}
							measureBeforeMount={true}
							className="layout"
							isDragable={false}
							isResizable={false}
						>
							{this.state.widgets.map((item, i) => {
								return this.renderWidget(item)

							})}
						</ResponsiveReactGridLayout>
						<Snackbar
							open={this.state.snackbarOn}
							autoHideDuration={3000}
							onClose={() => { this.handleCloseSnackBar() }}
							message="Sent"
						/>
					</div>
				)
			}
		}

		class Settings extends React.Component {
			constructor(props) {
				super(props);

				let groups = [];
				let settings = [];
				this.settingsIndex = 0;
				let currentConnectionType = CONNECTION_TYPE_HTTP;
				if (props.connectionType != undefined) {
					currentConnectionType = props.connectionType
				}
				if (props.server != undefined) {
					API_URL_BASE = 'props.server';
				}

				this.state = {
					groups: groups,
					settings: settings,
					activeGroup: undefined,
					settingsIndex: 0,
					commandQueue: [],
					loading: true,
					currentConnectionType
				}
			}

			componentDidMount() {
				fetchAPI('e=s&a=def', {
					method: 'GET',
					params: {
						'a': 'def', // get SDF file (exposed settings and definition)
					}
				}).then((response) => {
					return response.text();
				}).then((data) => {
					this.sdf = data;
					this.initSettings();
				});
			}

			initSettings() {
				this.descriptor = this.decodeSDF(this.sdf);
				let groups = [];
				let settings = [];
				let activeGroup = undefined;
				let currentGroup = '';
				for (var i = 0; i < this.descriptor.length; i++) {
					var setting = this.descriptor[i];
					setting.group = currentGroup;
					setting.disabled = true;
					setting.loading = true;
					if (setting.T != 'GROUP') {
						settings.push(setting);
					}
					else if (setting.T == 'GROUP') {
						var groupID = setting.I.replace('$', '');
						var desc = setting.D.split(' ').join('-');
						currentGroup = groupID;
						groups.push({
							id: groupID,
							name: desc
						});
					}
				}
				if (groups.length > 0) {
					activeGroup = groups[0]
				}
				this.setState({
					settings,
					groups,
					activeGroup
				}, () => this.refreshSettings());
			}

			render() {
				return (
					<Row>
						<h2>Settings</h2>
						<Tabs>
							{this.state.groups.map((group, i) => (
								<Tab
									eventKey={group.name}
									title={(
										<span>
											{group.name}
										</span>
									)}
									key={i}
								>
									<Form>
										{this.renderSettings()}
									</Form>
								</Tab>
							)
							)}
						</Tabs>
						<Row id="bottom">
							<Col id="actions">
								<br />
								{this.state.commandQueue.length == 0 ?
									<Button onClick={this.save.bind(this)}>Save</Button>
									: null}
								&nbsp;
								{this.state.commandQueue.length > 0 ?
									<Button onClick={this.cancel.bind(this)}>Cancel</Button>
									: null}
								&nbsp;
								{this.state.commandQueue.length == 0 ?
									<Button onClick={this.refreshSettings.bind(this)}>Refresh</Button>
									: null}
								&nbsp;
								{this.state.commandQueue.length == 0 ?
									<Button onClick={this.reboot.bind(this)}>Reboot Device</Button>
									: null}

							</Col>
						</Row>


					</Row>
				);
			}

			renderSidebar() {
				return this.state.groups.map((group, i) => {
					return (
						<ListGroup.Item as="li" active={this.state.activeGroup.id == group.id} onClick={() => this.setState({ activeGroup: group })}>
							{group.name}
						</ListGroup.Item>
					)
				})
			}

			renderSettings() {
				if (this.state.activeGroup != undefined) {
					let settings = [];
					for (let i = 0; i < this.state.settings.length; i++) {
						if (this.state.settings[i].group == this.state.activeGroup.id) {
							settings.push(this.state.settings[i]);
						}
					}
					return (settings.map((item, i) => {
						var fieldControl = '';
						var controlParts = item.C.split('/');
						var controlType = controlParts[0];
						switch (controlType) {
							case 'EDIT':
								switch (item.T) {
									case 'DATETIME':
										fieldControl = <input type="datetime-local" className="form-control" placeholder={item.D} />;
										break;
									case 'TIME':
										fieldControl = <input type="time" className="form-control" placeholder={item.D} />;
										break;
									default:
										fieldControl = <input type="text" className="form-control" placeholder={item.D} />;
										break;
								}
								break;
							case 'ETHERNETCTRL':
							case 'IPCTRL':
								fieldControl = <input type="text" className="form-control" placeholder={item.D} />;
								break;
							case 'STATIC':
							case 'SWITCH':
								if (item.O != undefined) {
									fieldControl = this.renderDropdown(item);
								}
								break;
							default:
								fieldControl = item.C;
								break;
						}
						fieldControl.props.disabled = item.disabled;
						if (item.VALUE !== undefined) {
							switch (item.T) {
								case 'DATETIME':
									const d = new Date(Number(item.VALUE) * 1000);
									const dateTimeLocalValue = (new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString()).slice(0, -1);
									fieldControl.props.value = dateTimeLocalValue;
									break;
								case 'TIME':
									const remainder = Number(item.VALUE) % 60;
									const hours = (Number(item.VALUE) - remainder) / 60;
									const minutes = remainder;
									fieldControl.props.value = hours.toString().padStart(2, '0') + ':' + minutes.toString().padStart(2, '0');
									break;
								default:
									fieldControl.props.value = item.VALUE;
									break;
							}
						}

						fieldControl.props.onChange = (e) => this.formChange(item, e);
						fieldControl.props.className += item.errorMessage != '' ? ' is-invalid' : '';
						let visibility = 'visible';
						if (item.hidden) {
							visibility = 'none';
						}
						var element =
							<Form.Group as={Row} visibility={visibility}>
								<label className="form-label" column sm={3}>{item.D}</label>
								<Col className="input-group" sm={9}>
									{fieldControl}
									{item.loading ?
										<div className="input-group-append">
											<span className="input-group-text">
												<Spinner animation="border" size="sm" />
											</span>
										</div>
										: null
									}

									<div className="invalid-feedback">
										{item.errorMessage}
									</div>
								</Col>
							</Form.Group>;

						return element;
					}));
				}
			}

			renderDropdown(item) {
				var valueParts = item.O.split('/');
				let options = [];
				let values = [];
				for (var j = 0; j < valueParts.length; j += 2) {
					if (valueParts[j].trim().length == 0) {
						continue;
					}
					values.push({
						label: valueParts[j],
						value: valueParts[j + 1]
					});
					options.push(
						<option key={j} value={valueParts[j + 1]}>{valueParts[j]}</option>
					)
				}
				if (options.length == 2) {
					return (
						<Switch id={"switch-" + item.I}
							trueValue={values[1].value}
							falseValue={values[0].value}
							trueLabel={values[1].label}
							falseLabel={values[0].label} />
					)
				}
				return (
					<Form.Control as="select">
						{options.map(option => option)}
					</Form.Control>
				)
			}

			refreshSettings() {
				this.settingsIndex = 0;
				let commandQueue = [];
				let settings = this.state.settings;
				for (var i = 0; i < settings.length; i++) {
					var setting = settings[i];
					var command = 'G' + setting.I;
					commandQueue.push(command);
					setting.loading = true;
					setting.disabled = true;
				}
				this.setState({
					settings,
					settingsIndex: 0,
					commandQueue: commandQueue
				}, () => this.processCommandQueue());

			}

			cancel() {
				this.setState({
					commandQueue: []
				}, () => this.processCommandQueue());
			}

			save() {
				var invalidSettings = this.validateForm();
				let commandQueue = [];
				if (invalidSettings.length > 0) {
					return;
				}
				let settings = this.state.settings;
				for (var i = 0; i < settings.length; i++) {
					var setting = settings[i];
					var settingValue = setting.VALUE;
					var settingString = setting.I;
					if (settingString.length > 2) {
						settingString += "@"; //add escape character to name
					}
					var command = 'S' + settingString + settingValue;
					commandQueue.push(command);
					setting.loading = true;
				}
				this.setState({
					settingsIndex: 0,
					commandQueue: commandQueue,
					settings
				}, () => this.processCommandQueue());
			}

			reboot() {
				if (confirm("Reboot Device?")) {
					this.sendCommand('E');
					alert("Device will now reboot");
				}
			}

			processCommandQueue() {
				if (this.state.commandQueue.length > 0) {
					let commandQueue = this.state.commandQueue;
					var command = commandQueue.shift();
					this.setState({
						commandQueue
					}, () => this.sendCommand(command));
				}
			}

			sendCommand(command) {
				var commandString = "\x02" + command.trim() + "\x0d";
				switch (this.state.currentConnectionType) {
					case CONNECTION_TYPE_BLE:
						if (window.ReactNativeWebView != undefined) {
							window.ReactNativeWebView.postMessage(commandString, '*');
						}
						else {
							window.postMessage(commandString, '*');
						}
						break;
					case CONNECTION_TYPE_HTTP:
						fetch(`${API_URL_BASE}/settings_web.html`, {
							method: 'post',
							body: commandString
						}).then((response) => {
							return response.text();
						}).then((data) => {
							this.processCommand(data);
						});
						break;
					default:

						break;
				}
			}

			processCommand(data) {
				var cursor = 0;
				var max = data.length;
				let settings = this.state.settings;
				let settingsIndex = this.state.settingsIndex;
				while (cursor < data.length) {
					var char = data[cursor++];
					if (char == "\x02") {
						var msg = '';
						//parse message
						char = data[cursor++];
						var status = char;
						if (char == 'A') {
							var index = 0;
							while (char != '\r' && index < 100) {
								char = data[cursor++];
								msg += char;
								index++;
							}
						}
						msg = msg.trim();
						var setting = settings[settingsIndex];
						setting.loading = false;
						setting.disabled = false;
						if (msg.length == 0) {
							switch (status.toUpperCase()) {
								case 'A':
									//ok has reply
									break;
								case 'R':
									//reject
									break;
								case 'C':
									//error

									break;
								case 'F':
									//failed
									break;
								default:

									break;
							}
						}
						else {
							var settingValue = msg;
							settings[settingsIndex].VALUE = settingValue;
							settings[settingsIndex].loading = false;
							settings[settingsIndex].disabled = false;

						}

						settingsIndex++;
					}
				}
				this.setState({
					settingsIndex,
					settings
				}, () => {
					this.validateForm();
					this.processCommandQueue();
					this.updateConstraints();
				});
			}

			validateForm() {
				//TODO: MAXLEN
				var invalidSettings = [];
				let settings = this.state.settings;

				for (var i = 0; i < settings.length; i++) {
					var item = settings[i];
					if (item.T != 'GROUP') {
						var settingName = item.I;
						var settingValue = item.VALUE;
						item.errorMessage = '';
						// $(`#setting-container-${setting.I} .invalid-feedback`).text('');
						if (item.disabled) {
							continue;
						}
						var itemValid = true;
						var message = "";
						if (item.V != undefined) {
							message = this.evaluateExpression(item.V);
							if (message.length > 0) {
								itemValid = false;
							}
						}
						switch (item.C) {
							case 'IPCTRL':
								itemValid = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.exec(settingValue) != null;
								message = 'invalid format';
								break;
							case 'ETHERNETCTRL':
								itemValid = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/.exec(settingValue) != null;
								message = 'invalid format';
								break;
							default:

								break;
						}
						if (!itemValid) {
							item.invalid = true;
							item.errorMessage = message;
							invalidSettings.push(settingName);
						}
						else {
							item.errorMessage = '';
						}
					}
				}
				this.setState({
					settings
				});
				return invalidSettings;
			}

			updateConstraints() {
				let settings = this.state.settings;
				for (var i = 0; i < settings.length; i++) {
					var item = settings[i];
					if (item.T != 'GROUP') {
						//whether to show the setting control
						if (item.S != undefined) {
							var finalState = this.evaluateExpression(item.S);
							finalState = finalState.toString().replaceAll('\"', '');
							switch (finalState) {
								//Relevant
								case "e":
									item.disabled = false;
									break;
								//Irrelevant
								case "i":
									item.disabled = true;
									break;
								//Modifiable
								case "a":
									item.disabled = false;
									break;
								case "h":
									item.hidden = true;
									break;
							}

						}
					}
				}

				this.setState({
					settings: settings
				});
			}

			evaluateExpression(expression) {
				var result = false;
				var geval = eval;
				try {
					for (var i = 0; i < this.descriptor.length; i++) {
						var item = this.descriptor[i];
						if (item.T == 'GROUP') {
							continue;
						}
						var val = this.getSetting(item.I).VALUE;
						if (val != undefined && val.length == 0) {
							switch (item.T) {
								case 'INT':
								case 'DECIMAL':
								case 'DWORD':
								case 'WORD':
								case 'SHORT':
								case 'BYTE':
									val = 0;
									break;
								case 'STRING':
									val = '\"\"';
									break;
							}
							if (item.T == 'INT') {
								val = 0;
							}
							else if (item.T == 'STRING') {
								val = '\"\"';
							}
						}
						else {
							switch (item.T) {
								case 'STRING':
									val = '\"' + val + '\"';
									break;
							}
						}
						var str = 'var ' + item.I + '=' + val;
						geval(str);
					}
					result = geval(expression);
				} catch (ex) {
					console.log(ex);
				}

				return result;
			}

			getSetting(settingId) {
				for (let i = 0; i < this.state.settings.length; i++) {
					if (this.state.settings[i].I == settingId) {
						return this.state.settings[i];
					}
				}

				return undefined;
			}

			formChange(setting, event) {
				let value = event.target.value;
				let settings = this.state.settings;
				for (let i = 0; i < settings.length; i++) {
					if (settings[i].I == setting.I) {
						switch (settings[i].T) {
							case 'DATETIME':
								const dateTimeLocalValue = value;
								const fakeUtcTime = new Date(`${dateTimeLocalValue}Z`);
								const d = new Date(fakeUtcTime.getTime() + fakeUtcTime.getTimezoneOffset() * 60000);
								settings[i].VALUE = Math.round(d.getTime() / 1000).toString();
								break;
							case 'TIME':
								const parts = value.split(':');
								const hours = parseInt(parts[0]);
								const minutes = parseInt(parts[1]);
								settings[i].VALUE = (hours * 60 + minutes).toString();
								break;
							default:
								settings[i].VALUE = value;
								break;
						}
					}
				}
				this.setState({
					settings
				}, () => {
					this.updateConstraints();
					this.validateForm();
				});
			}

			decodeSDF(str) {
				var settings = [];
				var lines = str.split('\n');
				for (var i = 0; i < lines.length; i++) {
					var line = lines[i].trim();
					if (line.length > 0) {
						const regex = /@\d/gm;
						line = line.replace(regex, '');
						var settingParts = line.split(';');

						var setting = {};
						for (var j = 0; j < settingParts.length; j++) {
							var parts = settingParts[j].split('=');
							var eqIndex = settingParts[j].indexOf('=');
							var fieldName = settingParts[j].substr(0, eqIndex);
							var value = settingParts[j].substr(eqIndex + 1);
							if (fieldName != "") {
								setting[fieldName] = value;
							}
						}
						if (setting.I == undefined || setting.T == undefined) {
							continue;
						}
						settings.push(setting);
					}
				}
				return settings;
			}

			ParseLine(Line) {
				var Obj = new Object;
				var Properties = Line.split("\x09"); //save to array (TAB)
				var PropertyCount = 0;
				Properties = cleanArray(Properties); //incase many "Tab" keys amount fields, get rid of it.


				for (var i = 0; i < Properties.length; i++) {
					var s = Properties[i];     //every line
					//(String(test7)
					if (s.substr(0, 1) != "#") {
						if (i == 0) var Name = 'NAME';
						if (i == 1) var Name = 'STORAGE';
						if (i == 2) var Name = 'TYPE';
						if (i == 3) var Name = 'MEMBER';
						if (i == 4) var Name = 'P1';
						if (i == 5) var Name = 'P2';
						if (i == 6) var Name = 'INI';
						if (i == 7) var Name = 'DEFVAL';
						if (i == 8) var Name = 'C';
					}
					else {
						if (i == 0) var Name = 'CONFIG'; //#define setting
					}

					var Value = s;

					Obj[Name] = Value;
					PropertyCount++;
				}

				if (!PropertyCount) // empty or ill-formatted line
					return null;

				// var Options = Obj.O ? ParseOptions(Obj.O) : null;
				// if (Options)
				//     Obj.Options = Options;


				return Obj;
			}

			ParseOptions(s) {
				var Options = new Array;

				var i = 0;
				for (; ;) {
					var j = s.indexOf("/", i);
					if (j == -1)
						break; // invalid option

					var Name = s.slice(i, j);

					i = j + 1;
					j = s.indexOf("/", i);      //pharse members?

					var Value = j != -1 ? s.slice(i, j) : s.slice(i);

					var Option = new Object;
					Option.Name = Name;
					Option.Value = Value;
					Options.push(Option);


					if (j == -1)
						break; // no more options

					i = j + 1;
				}

				if (!Options.length) // ill-formatted option string
					return null;

				return Options;
			}



			Encode(XText) {
				var Text = new String;

				for (var i = 0; i < XText.length; i++) {
					var s = FormatLine(XText[i]);
					Text += s;
					Text += "\r\n";
				}

				return Text;
			}

			FormatLine(Obj) {
				//	Obj.O = Obj.Options ? FormatOptions(Obj.Options) : null;

				var s = new String;

				for (var Property in Obj) {
					if (Property == "Options") // skip this property, it's already formatted into Obj.O
						continue;

					var Value = Obj[Property];

					if (!Value) // this property is empty
						continue;

					if (s.length != 0)
						s += "\x09";   //<<<<<<<<<<<<<<<<<<

					//s += Property;
					//s += "=";

					if (Property == "NAME") {
						s += ">>" + Value;
					}
					else {
						s += Value;
					}
				}

				return s;
			}
		}



		class DatabaseWrapper extends React.Component {
			render() {
				return (
					<Database />
				)
			}
		}

		class LogWrapper extends React.Component {
			render() {
				return (
					<Log />
				)
			}
		}

		class UnoWireSensors extends React.Component {
			constructor(props) {
				super(props);

				this.state = {
					sensors: UNOWIRE_SENSORS ? UNOWIRE_SENSORS : [],
					sensorsDetected: [],
					loading: false,
				}
				this.refresh = this.refresh.bind(this);
				this.scan = this.scan.bind(this);
				this.setSerial = this.setSerial.bind(this);
				this.save = this.save.bind(this);
			}

			componentDidMount() {
				this.refresh();
			}

			setSerial(id, serial) {
				const sensors = this.state.sensors;
				for (let i = 0; i < sensors.length; i++) {
					if (sensors[i].id == id) {
						sensors[i].serial = serial;
						break;
					}
				}
				this.setState({
					sensors: sensors
				});
			}

			async save() {
				if (this.state.sensors.length === 0) {
					return;
				}
				this.setState({
					loading: true,
				});
				const sensors = this.state.sensors;
				for (let i = 0; i < sensors.length; i++) {
					const sensor = sensors[i];
					try {
						const response = await fetch(`${API_URL_BASE}/unowires.html`, {
							method: 'post',
							body: `f=save&id=${sensor.id}&serial=${sensor.serial}`,
						});
					} catch (ex) {

					}
				}
				this.setState({
					loading: false,
				});
			}

			async refresh() {
				this.setState({
					loading: true,
				});
				const sensors = this.state.sensors;
				for (let i = 0; i < sensors.length; i++) {
					const sensor = sensors[i];
					try {
						let response = await fetch(`${API_URL_BASE}/unowires.html?f=get&id=${sensor.id}`, {
							method: 'get',
							cache: "no-cache",
						});
						let data = await response.text();
						sensors[i].serial = data.trim();
					} catch (ex) {

					}
				}
				this.setState({
					loading: false,
					sensors: sensors,
				});

			}

			async scan() {
				this.setState({
					loading: true,
					sensorsDetected: [],
				});
				try {
					const response = await fetch(`${API_URL_BASE}/unowires.html?f=scan`, {
						method: 'get',
						cache: "no-cache",
					});
					const data = await response.text();
					const lines = data.split('\n');
					const sensorsDetected = [];
					for (let i = 0; i < lines.length; i++) {
						const parts = lines[i].split('\t');
						if (parts.length == 2) {
							sensorsDetected.push({
								serial: parts[0],
								value: parts[1],
							});
						}
					}
					this.setState({
						loading: false,
						sensorsDetected: sensorsDetected,
					});
					alert(`${sensorsDetected.length} sensors detected`);
				} catch (ex) {
					this.setState({
						loading: false,
					});
				}
			}

			renderOptions(sensor) {
				let sensors = [
					...this.state.sensorsDetected
				];
				let result = [];
				if (sensor.serial && sensor.serial !== "") {
					result = this.state.sensorsDetected.filter(tmp => tmp.serial === sensor.serial);
				}
				if (sensor.serial !== "" && result.length === 0) {
					sensors.push({
						serial: sensor.serial,
						value: undefined,
					});
				}
				return (
					<select
						className="form-control"
						value={sensor.serial}
						onChange={(e) => this.setSerial(sensor.id, e.target.value)}
						disabled={this.state.loading}
					>
						<option value="">Unassigned</option>
						{sensors.map((tmpSensor, j) => {
							return (
								<option key={j} value={tmpSensor.serial}>
									{tmpSensor.serial}
									{tmpSensor.value !== undefined && (
										`(${tmpSensor.value})`
									)}
								</option>
							)
						})}
					</select>
				)
			}

			render() {
				return (
					<div>
						<h2>1-Wire Sensors</h2>

						<button
							type="button"
							className="btn btn-secondary mb-1 me-1"
							onClick={this.refresh}
							disabled={this.state.loading}
						>
							Refresh
						</button>
						<button
							type="button"
							className="btn btn-secondary mb-1"
							onClick={this.scan}
							disabled={this.state.loading}
						>
							Scan
						</button>
						<Table striped bordered hover>
							<thead>
								<tr>
									<th>Sensor Name</th>
									<th>Tibbit Channel</th>
									<th>Serial Number</th>
								</tr>
							</thead>
							<tbody>
								{this.state.sensors.map((sensor, i) => {
									return (
										<tr key={i}>
											<td>{sensor.name}</td>
											<td>{sensor.channel}</td>
											<td>
												{this.renderOptions(sensor)}
											</td>
										</tr>
									)
								})}
							</tbody>
						</Table>
						<button
							type="button"
							className="btn btn-secondary"
							onClick={this.save}
							disabled={this.state.loading}
						>
							Save
						</button>
					</div>
				)
			}
		}

		class Firmware extends React.Component {
			constructor(props) {
				super(props);
				this.state = {
					uploading: false,
					totalProgress: 0,
				};

				this.fileInput = React.createRef();
				this.handleSubmit = this.handleSubmit.bind(this);
			}

			componentDidMount() {
				if (this.progressTimer !== undefined) {
					clearInterval(this.progressTimer);
				}
				this.progressTimer = setInterval(() => {
					if (!this.state.uploading) {
						return;
					}
					fetch(`/upload_progress.html`)
						.then(res => res.text())
						.then(
							(result) => {
								this.setState({
									totalProgress: result,
								});
							},
							(error) => {
								console.log(error);
							}
						)
				}, 3000);
			}

			componentWillUnmount() {
				if (this.progressTimer !== undefined) {
					clearInterval(this.progressTimer);
				}
				this.progressTimer = undefined;
			}

			handleSubmit(event) {
				event.preventDefault();
				if (this.fileInput.current.files.length === 0) {
					alert("Please select a file");
					return;
				}
				const file = this.fileInput.current.files[0];
				const requestOptions = {
					method: 'POST',
					body: file,
				};
				this.setState({
					uploading: true,
					totalProgress: 0,
				});
				fetch(`/upload_firmware.html`, requestOptions)
					.then(
						(result) => {
							this.setState({
								uploading: false,
							});
							alert('Upload Completed');
						},
						(error) => {
							this.setState({
								uploading: false,
							});
							alert('Error uploading', error);
							console.error(error);
						}
					)
			}


			render() {
				return (
					<div>
						<h2>Firmware Upload</h2>
						<p>
							Upload a new firmware file (.tcu) to the Device
						</p>
						<div>
							<Form onSubmit={this.handleSubmit}>
								<Form.Control type="file" accept=".tcu" ref={this.fileInput} />
								<Button
									type="submit"
									variant="secondary"
									className="mt-2"
									disabled={this.state.uploading}
								>
									{this.state.uploading ? 'Uploading...' : 'Upload'}
								</Button>
								<br />
								<br />
								{this.state.uploading && (
									<ProgressBar variant="primary" now={this.state.totalProgress} label={`${this.state.totalProgress}%`} />
								)}
							</Form>
						</div>
					</div>
				)
			}
		}

		class Login extends React.Component {
			constructor(props) {
				super(props);
			}

			render() {
				return (
					<div>
						Login
					</div>
				)
			}
		}


		ReactDOM.render(
			<App />,
			document.getElementById('root'),
		);
	</script>

	<style>
		body {
			font-size: .875rem;
		}

		.feather {
			width: 16px;
			height: 16px;
		}

		/*
		* Sidebar
		*/

		.sidebar {
			position: fixed;
			top: 0;
			/* rtl:raw:
			right: 0;
			*/
			bottom: 0;
			/* rtl:remove */
			left: 0;
			z-index: 100;
			/* Behind the navbar */
			padding: 48px 0 0;
			/* Height of navbar */
			box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
		}

		.sidebar-sticky {
			position: relative;
			top: 0;
			height: calc(100vh - 48px);
			padding-top: .5rem;
			overflow-x: hidden;
			overflow-y: auto;
			/* Scrollable contents if viewport is shorter than content. */
		}

		.sidebar .nav-link {
			font-weight: 500;
			color: #333;
		}

		.sidebar .nav-link .feather {
			margin-right: 4px;
			color: #727272;
		}

		.sidebar .nav-link.active {
			color: #2470dc;
		}

		.sidebar .nav-link:hover .feather,
		.sidebar .nav-link.active .feather {
			color: inherit;
		}

		.sidebar-heading {
			font-size: .75rem;
		}

		/*
		* Navbar
		*/

		.navbar-brand {
			padding-top: .75rem;
			padding-bottom: .75rem;
			background-color: rgba(0, 0, 0, .25);
			box-shadow: inset -1px 0 0 rgba(0, 0, 0, .25);
		}

		.navbar .navbar-toggler {
			top: .25rem;
			right: 1rem;
		}

		.navbar .form-control {
			padding: .75rem 1rem;
		}

		.form-control-dark {
			color: #fff;
			background-color: rgba(255, 255, 255, .1);
			border-color: rgba(255, 255, 255, .1);
		}

		.form-control-dark:focus {
			border-color: transparent;
			box-shadow: 0 0 0 3px rgba(255, 255, 255, .25);
		}

		/* gauge styling */
		.gauge .value {
			position: absolute;
			bottom: 0%;
			left: 0;
			width: 100%;
			text-align: center;
			z-index: 5;
		}

		.gauge {
			width: 100%;
		}

		.gauge__body {
			width: 100%;
			height: 0;
			padding-bottom: 50%;
			background: #f2f2f2;
			position: relative;
			border-top-left-radius: 100% 200%;
			border-top-right-radius: 100% 200%;
			overflow: hidden;
		}

		.gauge__fill {
			position: absolute;
			top: 100%;
			left: 0;
			width: inherit;
			height: 100%;
			background: #1976d2;
			transform-origin: center top;
			transform: rotate(var(--angle));
			transition: transform 0.2s ease-out;
		}

		.gauge__cover {
			width: 75%;
			height: 150%;
			background: #ffffff;
			border-radius: 50%;
			position: absolute;
			top: 25%;
			left: 50%;
			transform: translateX(-50%);
		}
	</style>
</body>

</html>